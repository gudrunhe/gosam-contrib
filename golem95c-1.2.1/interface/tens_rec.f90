!****h* src/interface/tens_rec
! NAME
!
!  Module tens_rec
!
! USAGE
!
!  use tens_rec
!
! DESCRIPTION
!
!  This module offers the possibility of reconstructing the tensor
!  coefficients that have to be contracted with tensor integrals in
!  order to reproduce a diagram, which has been specified by a set
!  of denominators and a numerator N(q, mu^2). This module is typically
!  used in connection with the module tens_comb.
!
!  Please, note that this module is generated by a script and should not
!  be modified manually. In order to make changes to this module rerun
!  the Python script
!
!  tool/tens_rec/tens.py
!
! USES
!
!  * precision_golem (src/module/precision_golem.f90)
!
!*****
module tens_rec
use precision_golem, only: ki
implicit none
private :: ki
real(ki), dimension(0:3), parameter, private :: null_vec = &
 & (/0.0_ki,0.0_ki,0.0_ki,0.0_ki/)
real(ki), dimension(1,1), parameter, private :: mat1_1 = &
& reshape((/&
&1.0_ki/3.0_ki/),&
& (/1,1/), order=(/2,1/))
real(ki), dimension(1,1), parameter, private :: q1_1 = &
& reshape((/&
&3.0_ki/),&
& (/1,1/), order=(/2,1/))
real(ki), dimension(2,2), parameter, private :: mat2_1 = &
& reshape((/&
&5.0_ki/6.0_ki,-3.0_ki/10.0_ki,-1.0_ki/6.0_ki,1.0_ki/10.0_ki/),&
& (/2,2/), order=(/2,1/))
real(ki), dimension(2,1), parameter, private :: q2_1 = &
& reshape((/&
&3.0_ki,5.0_ki/),&
& (/2,1/), order=(/2,1/))
real(ki), dimension(1,1), parameter, private :: mat2_2 = &
& reshape((/&
&1.0_ki/9.0_ki/),&
& (/1,1/), order=(/2,1/))
real(ki), dimension(1,2), parameter, private :: q2_2 = &
& reshape((/&
&3.0_ki,3.0_ki/),&
& (/1,2/), order=(/2,1/))
real(ki), dimension(3,3), parameter, private :: mat3_1 = &
& reshape((/&
&35.0_ki/24.0_ki,-21.0_ki/20.0_ki,15.0_ki/56.0_ki,-1.0_ki/2.0_ki,1.0_ki/2.0_ki, &
&-1.0_ki/7.0_ki,1.0_ki/24.0_ki,-1.0_ki/20.0_ki,1.0_ki/56.0_ki/),&
& (/3,3/), order=(/2,1/))
real(ki), dimension(3,1), parameter, private :: q3_1 = &
& reshape((/&
&3.0_ki,5.0_ki,7.0_ki/),&
& (/3,1/), order=(/2,1/))
real(ki), dimension(3,3), parameter, private :: mat3_2 = &
& reshape((/&
&4.0_ki/9.0_ki,-1.0_ki/10.0_ki,-1.0_ki/10.0_ki,-1.0_ki/18.0_ki,1.0_ki/30.0_ki, &
&0.0_ki,-1.0_ki/18.0_ki,0.0_ki,1.0_ki/30.0_ki/),&
& (/3,3/), order=(/2,1/))
real(ki), dimension(3,2), parameter, private :: q3_2 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki/),&
& (/3,2/), order=(/2,1/))
real(ki), dimension(1,1), parameter, private :: mat3_3 = &
& reshape((/&
&1.0_ki/27.0_ki/),&
& (/1,1/), order=(/2,1/))
real(ki), dimension(1,3), parameter, private :: q3_3 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki/),&
& (/1,3/), order=(/2,1/))
real(ki), dimension(4,4), parameter, private :: mat4_1 = &
& reshape((/&
&385.0_ki/192.0_ki,-77.0_ki/40.0_ki,165.0_ki/224.0_ki,-35.0_ki/704.0_ki, &
&-167.0_ki/192.0_ki,131.0_ki/120.0_ki,-103.0_ki/224.0_ki,71.0_ki/2112.0_ki, &
&23.0_ki/192.0_ki,-7.0_ki/40.0_ki,19.0_ki/224.0_ki,-5.0_ki/704.0_ki, &
&-1.0_ki/192.0_ki,1.0_ki/120.0_ki,-1.0_ki/224.0_ki,1.0_ki/2112.0_ki/),&
& (/4,4/), order=(/2,1/))
real(ki), dimension(4,1), parameter, private :: q4_1 = &
& reshape((/&
&3.0_ki,5.0_ki,7.0_ki,11.0_ki/),&
& (/4,1/), order=(/2,1/))
real(ki), dimension(6,6), parameter, private :: mat4_2 = &
& reshape((/&
&10.0_ki/9.0_ki,-1.0_ki/2.0_ki,5.0_ki/56.0_ki,-1.0_ki/2.0_ki,9.0_ki/100.0_ki, &
&5.0_ki/56.0_ki,-1.0_ki/4.0_ki,13.0_ki/60.0_ki,-1.0_ki/21.0_ki,1.0_ki/20.0_ki, &
&-3.0_ki/100.0_ki,0.0_ki,1.0_ki/72.0_ki,-1.0_ki/60.0_ki,1.0_ki/168.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/4.0_ki,1.0_ki/20.0_ki,0.0_ki,13.0_ki/60.0_ki, &
&-3.0_ki/100.0_ki,-1.0_ki/21.0_ki,1.0_ki/36.0_ki,-1.0_ki/60.0_ki,0.0_ki, &
&-1.0_ki/60.0_ki,1.0_ki/100.0_ki,0.0_ki,1.0_ki/72.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/60.0_ki,0.0_ki,1.0_ki/168.0_ki/),&
& (/6,6/), order=(/2,1/))
real(ki), dimension(6,2), parameter, private :: q4_2 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki,7.0_ki, &
&3.0_ki/),&
& (/6,2/), order=(/2,1/))
real(ki), dimension(4,4), parameter, private :: mat4_3 = &
& reshape((/&
&11.0_ki/54.0_ki,-1.0_ki/30.0_ki,-1.0_ki/30.0_ki,-1.0_ki/30.0_ki, &
&-1.0_ki/54.0_ki,1.0_ki/90.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,0.0_ki, &
&1.0_ki/90.0_ki,0.0_ki,-1.0_ki/54.0_ki,0.0_ki,0.0_ki,1.0_ki/90.0_ki/),&
& (/4,4/), order=(/2,1/))
real(ki), dimension(4,3), parameter, private :: q4_3 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki, &
&3.0_ki/),&
& (/4,3/), order=(/2,1/))
real(ki), dimension(1,1), parameter, private :: mat4_4 = &
& reshape((/&
&1.0_ki/81.0_ki/),&
& (/1,1/), order=(/2,1/))
real(ki), dimension(1,4), parameter, private :: q4_4 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki/),&
& (/1,4/), order=(/2,1/))
real(ki), dimension(5,5), parameter, private :: mat5_1 = &
& reshape((/&
&1001.0_ki/384.0_ki,-1001.0_ki/320.0_ki,715.0_ki/448.0_ki,-455.0_ki/1408.0_ki, &
&77.0_ki/832.0_ki,-213.0_ki/160.0_ki,967.0_ki/480.0_ki,-47.0_ki/42.0_ki, &
&257.0_ki/1056.0_ki,-443.0_ki/6240.0_ki,233.0_ki/960.0_ki,-101.0_ki/240.0_ki, &
&25.0_ki/96.0_ki,-133.0_ki/2112.0_ki,59.0_ki/3120.0_ki,-3.0_ki/160.0_ki, &
&17.0_ki/480.0_ki,-1.0_ki/42.0_ki,7.0_ki/1056.0_ki,-1.0_ki/480.0_ki, &
&1.0_ki/1920.0_ki,-1.0_ki/960.0_ki,1.0_ki/1344.0_ki,-1.0_ki/4224.0_ki, &
&1.0_ki/12480.0_ki/),&
& (/5,5/), order=(/2,1/))
real(ki), dimension(5,1), parameter, private :: q5_1 = &
& reshape((/&
&3.0_ki,5.0_ki,7.0_ki,11.0_ki,13.0_ki/),&
& (/5,1/), order=(/2,1/))
real(ki), dimension(10,10), parameter, private :: mat5_2 = &
& reshape((/&
&605.0_ki/288.0_ki,-65.0_ki/48.0_ki,85.0_ki/224.0_ki,-35.0_ki/2112.0_ki, &
&-65.0_ki/48.0_ki,27.0_ki/50.0_ki,-9.0_ki/112.0_ki,85.0_ki/224.0_ki, &
&-9.0_ki/112.0_ki,-35.0_ki/2112.0_ki,-371.0_ki/576.0_ki,487.0_ki/720.0_ki, &
&-151.0_ki/672.0_ki,71.0_ki/6336.0_ki,11.0_ki/40.0_ki,-9.0_ki/40.0_ki, &
&3.0_ki/70.0_ki,-5.0_ki/112.0_ki,3.0_ki/112.0_ki,0.0_ki,35.0_ki/576.0_ki, &
&-1.0_ki/12.0_ki,25.0_ki/672.0_ki,-5.0_ki/2112.0_ki,-1.0_ki/80.0_ki, &
&3.0_ki/200.0_ki,-3.0_ki/560.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/576.0_ki, &
&1.0_ki/360.0_ki,-1.0_ki/672.0_ki,1.0_ki/6336.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-371.0_ki/576.0_ki,11.0_ki/40.0_ki,-5.0_ki/112.0_ki,0.0_ki, &
&487.0_ki/720.0_ki,-9.0_ki/40.0_ki,3.0_ki/112.0_ki,-151.0_ki/672.0_ki, &
&3.0_ki/70.0_ki,71.0_ki/6336.0_ki,5.0_ki/36.0_ki,-7.0_ki/60.0_ki, &
&1.0_ki/42.0_ki,0.0_ki,-7.0_ki/60.0_ki,9.0_ki/100.0_ki,-1.0_ki/70.0_ki, &
&1.0_ki/42.0_ki,-1.0_ki/70.0_ki,0.0_ki,-1.0_ki/144.0_ki,1.0_ki/120.0_ki, &
&-1.0_ki/336.0_ki,0.0_ki,1.0_ki/240.0_ki,-1.0_ki/200.0_ki,1.0_ki/560.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,35.0_ki/576.0_ki,-1.0_ki/80.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/12.0_ki,3.0_ki/200.0_ki,0.0_ki,25.0_ki/672.0_ki,-3.0_ki/560.0_ki, &
&-5.0_ki/2112.0_ki,-1.0_ki/144.0_ki,1.0_ki/240.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/120.0_ki,-1.0_ki/200.0_ki,0.0_ki,-1.0_ki/336.0_ki,1.0_ki/560.0_ki, &
&0.0_ki,-1.0_ki/576.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/672.0_ki,0.0_ki,1.0_ki/6336.0_ki/),&
& (/10,10/), order=(/2,1/))
real(ki), dimension(10,2), parameter, private :: q5_2 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,11.0_ki,5.0_ki,3.0_ki,5.0_ki, &
&5.0_ki,5.0_ki,7.0_ki,7.0_ki,3.0_ki,7.0_ki,5.0_ki,11.0_ki,3.0_ki/),&
& (/10,2/), order=(/2,1/))
real(ki), dimension(10,10), parameter, private :: mat5_3 = &
& reshape((/&
&143.0_ki/216.0_ki,-13.0_ki/60.0_ki,5.0_ki/168.0_ki,-13.0_ki/60.0_ki, &
&3.0_ki/100.0_ki,5.0_ki/168.0_ki,-13.0_ki/60.0_ki,3.0_ki/100.0_ki, &
&3.0_ki/100.0_ki,5.0_ki/168.0_ki,-1.0_ki/9.0_ki,4.0_ki/45.0_ki,-1.0_ki/63.0_ki, &
&1.0_ki/60.0_ki,-1.0_ki/100.0_ki,0.0_ki,1.0_ki/60.0_ki,-1.0_ki/100.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/216.0_ki,-1.0_ki/180.0_ki,1.0_ki/504.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/9.0_ki,1.0_ki/60.0_ki,0.0_ki, &
&4.0_ki/45.0_ki,-1.0_ki/100.0_ki,-1.0_ki/63.0_ki,1.0_ki/60.0_ki,0.0_ki, &
&-1.0_ki/100.0_ki,0.0_ki,1.0_ki/108.0_ki,-1.0_ki/180.0_ki,0.0_ki, &
&-1.0_ki/180.0_ki,1.0_ki/300.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/216.0_ki,0.0_ki,0.0_ki,-1.0_ki/180.0_ki,0.0_ki,1.0_ki/504.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-1.0_ki/9.0_ki,1.0_ki/60.0_ki,0.0_ki,1.0_ki/60.0_ki, &
&0.0_ki,0.0_ki,4.0_ki/45.0_ki,-1.0_ki/100.0_ki,-1.0_ki/100.0_ki, &
&-1.0_ki/63.0_ki,1.0_ki/108.0_ki,-1.0_ki/180.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/180.0_ki,1.0_ki/300.0_ki,0.0_ki,0.0_ki,1.0_ki/108.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/180.0_ki,0.0_ki,0.0_ki,-1.0_ki/180.0_ki,0.0_ki,1.0_ki/300.0_ki,0.0_ki, &
&1.0_ki/216.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/180.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/504.0_ki/),&
& (/10,10/), order=(/2,1/))
real(ki), dimension(10,3), parameter, private :: q5_3 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki, &
&3.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki, &
&3.0_ki,5.0_ki,5.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki/),&
& (/10,3/), order=(/2,1/))
real(ki), dimension(5,5), parameter, private :: mat5_4 = &
& reshape((/&
&7.0_ki/81.0_ki,-1.0_ki/90.0_ki,-1.0_ki/90.0_ki,-1.0_ki/90.0_ki, &
&-1.0_ki/90.0_ki,-1.0_ki/162.0_ki,1.0_ki/270.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/162.0_ki,0.0_ki,1.0_ki/270.0_ki,0.0_ki,0.0_ki,-1.0_ki/162.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/270.0_ki,0.0_ki,-1.0_ki/162.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/270.0_ki/),&
& (/5,5/), order=(/2,1/))
real(ki), dimension(5,4), parameter, private :: q5_4 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki, &
&3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki/),&
& (/5,4/), order=(/2,1/))
real(ki), dimension(6,6), parameter, private :: mat6_1 = &
& reshape((/&
&2431.0_ki/768.0_ki,-17017.0_ki/3840.0_ki,2431.0_ki/896.0_ki, &
&-7735.0_ki/8448.0_ki,1309.0_ki/3328.0_ki,-143.0_ki/6528.0_ki, &
&-48457.0_ki/26880.0_ki,35881.0_ki/11520.0_ki,-3959.0_ki/1920.0_ki, &
&18841.0_ki/25344.0_ki,-16217.0_ki/49920.0_ki,12673.0_ki/685440.0_ki, &
&5239.0_ki/13440.0_ki,-489.0_ki/640.0_ki,3727.0_ki/6720.0_ki, &
&-925.0_ki/4224.0_ki,2449.0_ki/24960.0_ki,-659.0_ki/114240.0_ki, &
&-77.0_ki/1920.0_ki,491.0_ki/5760.0_ki,-149.0_ki/2240.0_ki,371.0_ki/12672.0_ki, &
&-113.0_ki/8320.0_ki,41.0_ki/48960.0_ki,53.0_ki/26880.0_ki,-17.0_ki/3840.0_ki, &
&7.0_ki/1920.0_ki,-5.0_ki/2816.0_ki,43.0_ki/49920.0_ki,-13.0_ki/228480.0_ki, &
&-1.0_ki/26880.0_ki,1.0_ki/11520.0_ki,-1.0_ki/13440.0_ki,1.0_ki/25344.0_ki, &
&-1.0_ki/49920.0_ki,1.0_ki/685440.0_ki/),&
& (/6,6/), order=(/2,1/))
real(ki), dimension(6,1), parameter, private :: q6_1 = &
& reshape((/&
&3.0_ki,5.0_ki,7.0_ki,11.0_ki,13.0_ki,17.0_ki/),&
& (/6,1/), order=(/2,1/))
real(ki), dimension(15,15), parameter, private :: mat6_2 = &
& reshape((/&
&1981.0_ki/576.0_ki,-1085.0_ki/384.0_ki,205.0_ki/192.0_ki,-35.0_ki/264.0_ki, &
&77.0_ki/2496.0_ki,-1085.0_ki/384.0_ki,651.0_ki/400.0_ki,-27.0_ki/64.0_ki, &
&21.0_ki/1408.0_ki,205.0_ki/192.0_ki,-27.0_ki/64.0_ki,225.0_ki/3136.0_ki, &
&-35.0_ki/264.0_ki,21.0_ki/1408.0_ki,77.0_ki/2496.0_ki,-1231.0_ki/960.0_ki, &
&9127.0_ki/5760.0_ki,-2791.0_ki/4032.0_ki,1241.0_ki/12672.0_ki, &
&-443.0_ki/18720.0_ki,1501.0_ki/1920.0_ki,-79.0_ki/100.0_ki,549.0_ki/2240.0_ki, &
&-71.0_ki/7040.0_ki,-95.0_ki/448.0_ki,81.0_ki/448.0_ki,-15.0_ki/392.0_ki, &
&35.0_ki/4224.0_ki,-7.0_ki/1408.0_ki,0.0_ki,961.0_ki/5760.0_ki, &
&-373.0_ki/1440.0_ki,283.0_ki/2016.0_ki,-311.0_ki/12672.0_ki,59.0_ki/9360.0_ki, &
&-43.0_ki/640.0_ki,9.0_ki/100.0_ki,-87.0_ki/2240.0_ki,3.0_ki/1408.0_ki, &
&5.0_ki/448.0_ki,-3.0_ki/224.0_ki,15.0_ki/3136.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/1920.0_ki,23.0_ki/1440.0_ki,-41.0_ki/4032.0_ki,31.0_ki/12672.0_ki, &
&-1.0_ki/1440.0_ki,1.0_ki/640.0_ki,-1.0_ki/400.0_ki,3.0_ki/2240.0_ki, &
&-1.0_ki/7040.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/5760.0_ki, &
&-1.0_ki/2880.0_ki,1.0_ki/4032.0_ki,-1.0_ki/12672.0_ki,1.0_ki/37440.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1231.0_ki/960.0_ki,1501.0_ki/1920.0_ki,-95.0_ki/448.0_ki,35.0_ki/4224.0_ki, &
&0.0_ki,9127.0_ki/5760.0_ki,-79.0_ki/100.0_ki,81.0_ki/448.0_ki, &
&-7.0_ki/1408.0_ki,-2791.0_ki/4032.0_ki,549.0_ki/2240.0_ki,-15.0_ki/392.0_ki, &
&1241.0_ki/12672.0_ki,-71.0_ki/7040.0_ki,-443.0_ki/18720.0_ki, &
&215.0_ki/576.0_ki,-2221.0_ki/5760.0_ki,167.0_ki/1344.0_ki,-71.0_ki/12672.0_ki, &
&0.0_ki,-2221.0_ki/5760.0_ki,221.0_ki/600.0_ki,-33.0_ki/320.0_ki, &
&71.0_ki/21120.0_ki,167.0_ki/1344.0_ki,-33.0_ki/320.0_ki,1.0_ki/49.0_ki, &
&-71.0_ki/12672.0_ki,71.0_ki/21120.0_ki,0.0_ki,-13.0_ki/384.0_ki, &
&11.0_ki/240.0_ki,-9.0_ki/448.0_ki,5.0_ki/4224.0_ki,0.0_ki,11.0_ki/384.0_ki, &
&-3.0_ki/80.0_ki,1.0_ki/64.0_ki,-1.0_ki/1408.0_ki,-1.0_ki/168.0_ki, &
&1.0_ki/140.0_ki,-1.0_ki/392.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1152.0_ki, &
&-1.0_ki/720.0_ki,1.0_ki/1344.0_ki,-1.0_ki/12672.0_ki,0.0_ki,-1.0_ki/1920.0_ki, &
&1.0_ki/1200.0_ki,-1.0_ki/2240.0_ki,1.0_ki/21120.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,961.0_ki/5760.0_ki,-43.0_ki/640.0_ki,5.0_ki/448.0_ki, &
&0.0_ki,0.0_ki,-373.0_ki/1440.0_ki,9.0_ki/100.0_ki,-3.0_ki/224.0_ki,0.0_ki, &
&283.0_ki/2016.0_ki,-87.0_ki/2240.0_ki,15.0_ki/3136.0_ki,-311.0_ki/12672.0_ki, &
&3.0_ki/1408.0_ki,59.0_ki/9360.0_ki,-13.0_ki/384.0_ki,11.0_ki/384.0_ki, &
&-1.0_ki/168.0_ki,0.0_ki,0.0_ki,11.0_ki/240.0_ki,-3.0_ki/80.0_ki, &
&1.0_ki/140.0_ki,0.0_ki,-9.0_ki/448.0_ki,1.0_ki/64.0_ki,-1.0_ki/392.0_ki, &
&5.0_ki/4224.0_ki,-1.0_ki/1408.0_ki,0.0_ki,1.0_ki/576.0_ki,-1.0_ki/480.0_ki, &
&1.0_ki/1344.0_ki,0.0_ki,0.0_ki,-1.0_ki/480.0_ki,1.0_ki/400.0_ki, &
&-1.0_ki/1120.0_ki,0.0_ki,1.0_ki/1344.0_ki,-1.0_ki/1120.0_ki,1.0_ki/3136.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-17.0_ki/1920.0_ki,1.0_ki/640.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&23.0_ki/1440.0_ki,-1.0_ki/400.0_ki,0.0_ki,0.0_ki,-41.0_ki/4032.0_ki, &
&3.0_ki/2240.0_ki,0.0_ki,31.0_ki/12672.0_ki,-1.0_ki/7040.0_ki, &
&-1.0_ki/1440.0_ki,1.0_ki/1152.0_ki,-1.0_ki/1920.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/720.0_ki,1.0_ki/1200.0_ki,0.0_ki,0.0_ki,1.0_ki/1344.0_ki, &
&-1.0_ki/2240.0_ki,0.0_ki,-1.0_ki/12672.0_ki,1.0_ki/21120.0_ki,0.0_ki, &
&1.0_ki/5760.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/2880.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki,-1.0_ki/12672.0_ki,0.0_ki, &
&1.0_ki/37440.0_ki/),&
& (/15,15/), order=(/2,1/))
real(ki), dimension(15,2), parameter, private :: q6_2 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,11.0_ki,3.0_ki,13.0_ki, &
&5.0_ki,3.0_ki,5.0_ki,5.0_ki,5.0_ki,7.0_ki,5.0_ki,11.0_ki,7.0_ki,3.0_ki,7.0_ki, &
&5.0_ki,7.0_ki,7.0_ki,11.0_ki,3.0_ki,11.0_ki,5.0_ki,13.0_ki,3.0_ki/),&
& (/15,2/), order=(/2,1/))
real(ki), dimension(20,20), parameter, private :: mat6_3 = &
& reshape((/&
&2755.0_ki/1728.0_ki,-55.0_ki/72.0_ki,115.0_ki/672.0_ki,-35.0_ki/6336.0_ki, &
&-55.0_ki/72.0_ki,9.0_ki/40.0_ki,-3.0_ki/112.0_ki,115.0_ki/672.0_ki, &
&-3.0_ki/112.0_ki,-35.0_ki/6336.0_ki,-55.0_ki/72.0_ki,9.0_ki/40.0_ki, &
&-3.0_ki/112.0_ki,9.0_ki/40.0_ki,-27.0_ki/1000.0_ki,-3.0_ki/112.0_ki, &
&115.0_ki/672.0_ki,-3.0_ki/112.0_ki,-3.0_ki/112.0_ki,-35.0_ki/6336.0_ki, &
&-647.0_ki/1728.0_ki,383.0_ki/1080.0_ki,-199.0_ki/2016.0_ki,71.0_ki/19008.0_ki, &
&7.0_ki/60.0_ki,-9.0_ki/100.0_ki,1.0_ki/70.0_ki,-5.0_ki/336.0_ki, &
&1.0_ki/112.0_ki,0.0_ki,7.0_ki/60.0_ki,-9.0_ki/100.0_ki,1.0_ki/70.0_ki, &
&-3.0_ki/200.0_ki,9.0_ki/1000.0_ki,0.0_ki,-5.0_ki/336.0_ki,1.0_ki/112.0_ki, &
&0.0_ki,0.0_ki,47.0_ki/1728.0_ki,-13.0_ki/360.0_ki,31.0_ki/2016.0_ki, &
&-5.0_ki/6336.0_ki,-1.0_ki/240.0_ki,1.0_ki/200.0_ki,-1.0_ki/560.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/240.0_ki,1.0_ki/200.0_ki,-1.0_ki/560.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1728.0_ki,1.0_ki/1080.0_ki, &
&-1.0_ki/2016.0_ki,1.0_ki/19008.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-647.0_ki/1728.0_ki,7.0_ki/60.0_ki,-5.0_ki/336.0_ki,0.0_ki,383.0_ki/1080.0_ki, &
&-9.0_ki/100.0_ki,1.0_ki/112.0_ki,-199.0_ki/2016.0_ki,1.0_ki/70.0_ki, &
&71.0_ki/19008.0_ki,7.0_ki/60.0_ki,-3.0_ki/200.0_ki,0.0_ki,-9.0_ki/100.0_ki, &
&9.0_ki/1000.0_ki,1.0_ki/70.0_ki,-5.0_ki/336.0_ki,0.0_ki,1.0_ki/112.0_ki, &
&0.0_ki,13.0_ki/216.0_ki,-17.0_ki/360.0_ki,1.0_ki/126.0_ki,0.0_ki, &
&-17.0_ki/360.0_ki,7.0_ki/200.0_ki,-1.0_ki/210.0_ki,1.0_ki/126.0_ki, &
&-1.0_ki/210.0_ki,0.0_ki,-1.0_ki/120.0_ki,1.0_ki/200.0_ki,0.0_ki, &
&1.0_ki/200.0_ki,-3.0_ki/1000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/432.0_ki,1.0_ki/360.0_ki,-1.0_ki/1008.0_ki,0.0_ki,1.0_ki/720.0_ki, &
&-1.0_ki/600.0_ki,1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,47.0_ki/1728.0_ki, &
&-1.0_ki/240.0_ki,0.0_ki,0.0_ki,-13.0_ki/360.0_ki,1.0_ki/200.0_ki,0.0_ki, &
&31.0_ki/2016.0_ki,-1.0_ki/560.0_ki,-5.0_ki/6336.0_ki,-1.0_ki/240.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/200.0_ki,0.0_ki,-1.0_ki/560.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/432.0_ki,1.0_ki/720.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki, &
&-1.0_ki/600.0_ki,0.0_ki,-1.0_ki/1008.0_ki,1.0_ki/1680.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1728.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/2016.0_ki,0.0_ki,1.0_ki/19008.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-647.0_ki/1728.0_ki,7.0_ki/60.0_ki, &
&-5.0_ki/336.0_ki,0.0_ki,7.0_ki/60.0_ki,-3.0_ki/200.0_ki,0.0_ki, &
&-5.0_ki/336.0_ki,0.0_ki,0.0_ki,383.0_ki/1080.0_ki,-9.0_ki/100.0_ki, &
&1.0_ki/112.0_ki,-9.0_ki/100.0_ki,9.0_ki/1000.0_ki,1.0_ki/112.0_ki, &
&-199.0_ki/2016.0_ki,1.0_ki/70.0_ki,1.0_ki/70.0_ki,71.0_ki/19008.0_ki, &
&13.0_ki/216.0_ki,-17.0_ki/360.0_ki,1.0_ki/126.0_ki,0.0_ki,-1.0_ki/120.0_ki, &
&1.0_ki/200.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-17.0_ki/360.0_ki,7.0_ki/200.0_ki, &
&-1.0_ki/210.0_ki,1.0_ki/200.0_ki,-3.0_ki/1000.0_ki,0.0_ki,1.0_ki/126.0_ki, &
&-1.0_ki/210.0_ki,0.0_ki,0.0_ki,-1.0_ki/432.0_ki,1.0_ki/360.0_ki, &
&-1.0_ki/1008.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/720.0_ki,-1.0_ki/600.0_ki,1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,13.0_ki/216.0_ki,-1.0_ki/120.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/360.0_ki,1.0_ki/200.0_ki,0.0_ki,1.0_ki/126.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/360.0_ki,1.0_ki/200.0_ki,0.0_ki,7.0_ki/200.0_ki,-3.0_ki/1000.0_ki, &
&-1.0_ki/210.0_ki,1.0_ki/126.0_ki,0.0_ki,-1.0_ki/210.0_ki,0.0_ki, &
&-1.0_ki/216.0_ki,1.0_ki/360.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki, &
&-1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki,-1.0_ki/600.0_ki, &
&0.0_ki,-1.0_ki/600.0_ki,1.0_ki/1000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/432.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1008.0_ki,0.0_ki,0.0_ki,1.0_ki/720.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/600.0_ki,0.0_ki,1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&47.0_ki/1728.0_ki,-1.0_ki/240.0_ki,0.0_ki,0.0_ki,-1.0_ki/240.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-13.0_ki/360.0_ki,1.0_ki/200.0_ki,0.0_ki, &
&1.0_ki/200.0_ki,0.0_ki,0.0_ki,31.0_ki/2016.0_ki,-1.0_ki/560.0_ki, &
&-1.0_ki/560.0_ki,-5.0_ki/6336.0_ki,-1.0_ki/432.0_ki,1.0_ki/720.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki, &
&-1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1008.0_ki, &
&1.0_ki/1680.0_ki,0.0_ki,0.0_ki,-1.0_ki/432.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/720.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/360.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/600.0_ki,0.0_ki,0.0_ki,-1.0_ki/1008.0_ki,0.0_ki, &
&1.0_ki/1680.0_ki,0.0_ki,-1.0_ki/1728.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/2016.0_ki,0.0_ki,0.0_ki,1.0_ki/19008.0_ki/),&
& (/20,20/), order=(/2,1/))
real(ki), dimension(20,3), parameter, private :: q6_3 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki, &
&11.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki, &
&7.0_ki,3.0_ki,3.0_ki,7.0_ki,5.0_ki,3.0_ki,11.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki, &
&5.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,7.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki, &
&5.0_ki,5.0_ki,7.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,7.0_ki, &
&5.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki/),&
& (/20,3/), order=(/2,1/))
real(ki), dimension(15,15), parameter, private :: mat6_4 = &
& reshape((/&
&28.0_ki/81.0_ki,-4.0_ki/45.0_ki,5.0_ki/504.0_ki,-4.0_ki/45.0_ki, &
&1.0_ki/100.0_ki,5.0_ki/504.0_ki,-4.0_ki/45.0_ki,1.0_ki/100.0_ki, &
&1.0_ki/100.0_ki,5.0_ki/504.0_ki,-4.0_ki/45.0_ki,1.0_ki/100.0_ki, &
&1.0_ki/100.0_ki,1.0_ki/100.0_ki,5.0_ki/504.0_ki,-5.0_ki/108.0_ki, &
&19.0_ki/540.0_ki,-1.0_ki/189.0_ki,1.0_ki/180.0_ki,-1.0_ki/300.0_ki,0.0_ki, &
&1.0_ki/180.0_ki,-1.0_ki/300.0_ki,0.0_ki,0.0_ki,1.0_ki/180.0_ki, &
&-1.0_ki/300.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/648.0_ki,-1.0_ki/540.0_ki, &
&1.0_ki/1512.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-5.0_ki/108.0_ki,1.0_ki/180.0_ki,0.0_ki, &
&19.0_ki/540.0_ki,-1.0_ki/300.0_ki,-1.0_ki/189.0_ki,1.0_ki/180.0_ki,0.0_ki, &
&-1.0_ki/300.0_ki,0.0_ki,1.0_ki/180.0_ki,0.0_ki,-1.0_ki/300.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/324.0_ki,-1.0_ki/540.0_ki,0.0_ki,-1.0_ki/540.0_ki,1.0_ki/900.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/648.0_ki,0.0_ki,0.0_ki,-1.0_ki/540.0_ki,0.0_ki,1.0_ki/1512.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-5.0_ki/108.0_ki, &
&1.0_ki/180.0_ki,0.0_ki,1.0_ki/180.0_ki,0.0_ki,0.0_ki,19.0_ki/540.0_ki, &
&-1.0_ki/300.0_ki,-1.0_ki/300.0_ki,-1.0_ki/189.0_ki,1.0_ki/180.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/300.0_ki,0.0_ki,1.0_ki/324.0_ki,-1.0_ki/540.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/540.0_ki,1.0_ki/900.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/324.0_ki,0.0_ki,0.0_ki,-1.0_ki/540.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/540.0_ki,0.0_ki,1.0_ki/900.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/648.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/540.0_ki,0.0_ki,0.0_ki,1.0_ki/1512.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-5.0_ki/108.0_ki,1.0_ki/180.0_ki,0.0_ki,1.0_ki/180.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/180.0_ki,0.0_ki,0.0_ki,0.0_ki,19.0_ki/540.0_ki,-1.0_ki/300.0_ki, &
&-1.0_ki/300.0_ki,-1.0_ki/300.0_ki,-1.0_ki/189.0_ki,1.0_ki/324.0_ki, &
&-1.0_ki/540.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/540.0_ki,1.0_ki/900.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/324.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/540.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/540.0_ki,0.0_ki,1.0_ki/900.0_ki,0.0_ki,0.0_ki,1.0_ki/324.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/540.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/540.0_ki,0.0_ki,0.0_ki,1.0_ki/900.0_ki,0.0_ki,1.0_ki/648.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/540.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/1512.0_ki/),&
& (/15,15/), order=(/2,1/))
real(ki), dimension(15,4), parameter, private :: q6_4 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki, &
&7.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,3.0_ki, &
&7.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki, &
&5.0_ki,5.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki, &
&5.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki, &
&3.0_ki,7.0_ki,3.0_ki,3.0_ki,3.0_ki/),&
& (/15,4/), order=(/2,1/))
real(ki), dimension(7,7), parameter, private :: mat7_1 = &
& reshape((/&
&46189.0_ki/12288.0_ki,-46189.0_ki/7680.0_ki,46189.0_ki/10752.0_ki, &
&-146965.0_ki/67584.0_ki,24871.0_ki/19968.0_ki,-2717.0_ki/13056.0_ki, &
&12155.0_ki/233472.0_ki,-41907.0_ki/17920.0_ki,73279.0_ki/16128.0_ki, &
&-140753.0_ki/40320.0_ki,1489.0_ki/792.0_ki,-163879.0_ki/149760.0_ki, &
&127901.0_ki/685440.0_ki,-28807.0_ki/612864.0_ki,82513.0_ki/143360.0_ki, &
&-29017.0_ki/23040.0_ki,169339.0_ki/161280.0_ki,-124291.0_ki/202752.0_ki, &
&109279.0_ki/299520.0_ki,-87799.0_ki/1370880.0_ki,11413.0_ki/700416.0_ki, &
&-129.0_ki/1792.0_ki,1373.0_ki/8064.0_ki,-611.0_ki/4032.0_ki, &
&307.0_ki/3168.0_ki,-889.0_ki/14976.0_ki,743.0_ki/68544.0_ki, &
&-857.0_ki/306432.0_ki,139.0_ki/28672.0_ki,-1951.0_ki/161280.0_ki, &
&365.0_ki/32256.0_ki,-1597.0_ki/202752.0_ki,23.0_ki/4608.0_ki, &
&-263.0_ki/274176.0_ki,1237.0_ki/4902912.0_ki,-3.0_ki/17920.0_ki, &
&1.0_ki/2304.0_ki,-17.0_ki/40320.0_ki,1.0_ki/3168.0_ki,-31.0_ki/149760.0_ki, &
&29.0_ki/685440.0_ki,-1.0_ki/87552.0_ki,1.0_ki/430080.0_ki,-1.0_ki/161280.0_ki, &
&1.0_ki/161280.0_ki,-1.0_ki/202752.0_ki,1.0_ki/299520.0_ki, &
&-1.0_ki/1370880.0_ki,1.0_ki/4902912.0_ki/),&
& (/7,7/), order=(/2,1/))
real(ki), dimension(7,1), parameter, private :: q7_1 = &
& reshape((/&
&3.0_ki,5.0_ki,7.0_ki,11.0_ki,13.0_ki,17.0_ki,19.0_ki/),&
& (/7,1/), order=(/2,1/))
real(ki), dimension(21,21), parameter, private :: mat7_2 = &
& reshape((/&
&11743.0_ki/2304.0_ki,-57589.0_ki/11520.0_ki,3547.0_ki/1536.0_ki, &
&-25235.0_ki/50688.0_ki,1771.0_ki/9984.0_ki,-143.0_ki/19584.0_ki, &
&-57589.0_ki/11520.0_ki,5859.0_ki/1600.0_ki,-81.0_ki/64.0_ki, &
&189.0_ki/1408.0_ki,-231.0_ki/8320.0_ki,3547.0_ki/1536.0_ki,-81.0_ki/64.0_ki, &
&2025.0_ki/6272.0_ki,-75.0_ki/5632.0_ki,-25235.0_ki/50688.0_ki, &
&189.0_ki/1408.0_ki,-75.0_ki/5632.0_ki,1771.0_ki/9984.0_ki,-231.0_ki/8320.0_ki, &
&-143.0_ki/19584.0_ki,-352211.0_ki/161280.0_ki,52901.0_ki/17280.0_ki, &
&-130021.0_ki/80640.0_ki,59381.0_ki/152064.0_ki,-21533.0_ki/149760.0_ki, &
&12673.0_ki/2056320.0_ki,32443.0_ki/19200.0_ki,-6339.0_ki/3200.0_ki, &
&3609.0_ki/4480.0_ki,-1383.0_ki/14080.0_ki,443.0_ki/20800.0_ki, &
&-6565.0_ki/10752.0_ki,549.0_ki/896.0_ki,-2385.0_ki/12544.0_ki, &
&355.0_ki/39424.0_ki,595.0_ki/8448.0_ki,-147.0_ki/2816.0_ki,5.0_ki/704.0_ki, &
&-77.0_ki/4992.0_ki,77.0_ki/8320.0_ki,0.0_ki,28139.0_ki/80640.0_ki, &
&-2311.0_ki/3840.0_ki,60941.0_ki/161280.0_ki,-5521.0_ki/50688.0_ki, &
&3157.0_ki/74880.0_ki,-659.0_ki/342720.0_ki,-3823.0_ki/19200.0_ki, &
&241.0_ki/800.0_ki,-141.0_ki/896.0_ki,31.0_ki/1280.0_ki,-59.0_ki/10400.0_ki, &
&185.0_ki/3584.0_ki,-9.0_ki/128.0_ki,195.0_ki/6272.0_ki,-75.0_ki/39424.0_ki, &
&-35.0_ki/16896.0_ki,7.0_ki/2816.0_ki,-5.0_ki/5632.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-599.0_ki/23040.0_ki,887.0_ki/17280.0_ki,-991.0_ki/26880.0_ki, &
&2033.0_ki/152064.0_ki,-139.0_ki/24960.0_ki,41.0_ki/146880.0_ki, &
&61.0_ki/6400.0_ki,-27.0_ki/1600.0_ki,47.0_ki/4480.0_ki,-3.0_ki/1280.0_ki, &
&1.0_ki/1600.0_ki,-5.0_ki/3584.0_ki,1.0_ki/448.0_ki,-15.0_ki/12544.0_ki, &
&5.0_ki/39424.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&37.0_ki/40320.0_ki,-23.0_ki/11520.0_ki,1.0_ki/630.0_ki,-1.0_ki/1408.0_ki, &
&49.0_ki/149760.0_ki,-13.0_ki/685440.0_ki,-1.0_ki/6400.0_ki,1.0_ki/3200.0_ki, &
&-1.0_ki/4480.0_ki,1.0_ki/14080.0_ki,-1.0_ki/41600.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/80640.0_ki, &
&1.0_ki/34560.0_ki,-1.0_ki/40320.0_ki,1.0_ki/76032.0_ki,-1.0_ki/149760.0_ki, &
&1.0_ki/2056320.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-352211.0_ki/161280.0_ki, &
&32443.0_ki/19200.0_ki,-6565.0_ki/10752.0_ki,595.0_ki/8448.0_ki, &
&-77.0_ki/4992.0_ki,0.0_ki,52901.0_ki/17280.0_ki,-6339.0_ki/3200.0_ki, &
&549.0_ki/896.0_ki,-147.0_ki/2816.0_ki,77.0_ki/8320.0_ki, &
&-130021.0_ki/80640.0_ki,3609.0_ki/4480.0_ki,-2385.0_ki/12544.0_ki, &
&5.0_ki/704.0_ki,59381.0_ki/152064.0_ki,-1383.0_ki/14080.0_ki, &
&355.0_ki/39424.0_ki,-21533.0_ki/149760.0_ki,443.0_ki/20800.0_ki, &
&12673.0_ki/2056320.0_ki,557.0_ki/720.0_ki,-6701.0_ki/7200.0_ki, &
&1583.0_ki/4032.0_ki,-41.0_ki/792.0_ki,443.0_ki/37440.0_ki,0.0_ki, &
&-6701.0_ki/7200.0_ki,821.0_ki/800.0_ki,-213.0_ki/560.0_ki,133.0_ki/3520.0_ki, &
&-443.0_ki/62400.0_ki,1583.0_ki/4032.0_ki,-213.0_ki/560.0_ki,87.0_ki/784.0_ki, &
&-71.0_ki/14784.0_ki,-41.0_ki/792.0_ki,133.0_ki/3520.0_ki,-71.0_ki/14784.0_ki, &
&443.0_ki/37440.0_ki,-443.0_ki/62400.0_ki,0.0_ki,-2207.0_ki/23040.0_ki, &
&1693.0_ki/11520.0_ki,-2525.0_ki/32256.0_ki,163.0_ki/12672.0_ki, &
&-59.0_ki/18720.0_ki,0.0_ki,2789.0_ki/28800.0_ki,-17.0_ki/120.0_ki, &
&79.0_ki/1120.0_ki,-193.0_ki/21120.0_ki,59.0_ki/31200.0_ki,-163.0_ki/5376.0_ki, &
&183.0_ki/4480.0_ki,-223.0_ki/12544.0_ki,5.0_ki/4928.0_ki,71.0_ki/50688.0_ki, &
&-71.0_ki/42240.0_ki,71.0_ki/118272.0_ki,0.0_ki,0.0_ki,0.0_ki,7.0_ki/1440.0_ki, &
&-5.0_ki/576.0_ki,11.0_ki/2016.0_ki,-1.0_ki/792.0_ki,1.0_ki/2880.0_ki,0.0_ki, &
&-19.0_ki/4800.0_ki,11.0_ki/1600.0_ki,-1.0_ki/240.0_ki,3.0_ki/3520.0_ki, &
&-1.0_ki/4800.0_ki,1.0_ki/1344.0_ki,-1.0_ki/840.0_ki,1.0_ki/1568.0_ki, &
&-1.0_ki/14784.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/11520.0_ki,1.0_ki/5760.0_ki,-1.0_ki/8064.0_ki,1.0_ki/25344.0_ki, &
&-1.0_ki/74880.0_ki,0.0_ki,1.0_ki/19200.0_ki,-1.0_ki/9600.0_ki, &
&1.0_ki/13440.0_ki,-1.0_ki/42240.0_ki,1.0_ki/124800.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,28139.0_ki/80640.0_ki, &
&-3823.0_ki/19200.0_ki,185.0_ki/3584.0_ki,-35.0_ki/16896.0_ki,0.0_ki,0.0_ki, &
&-2311.0_ki/3840.0_ki,241.0_ki/800.0_ki,-9.0_ki/128.0_ki,7.0_ki/2816.0_ki, &
&0.0_ki,60941.0_ki/161280.0_ki,-141.0_ki/896.0_ki,195.0_ki/6272.0_ki, &
&-5.0_ki/5632.0_ki,-5521.0_ki/50688.0_ki,31.0_ki/1280.0_ki,-75.0_ki/39424.0_ki, &
&3157.0_ki/74880.0_ki,-59.0_ki/10400.0_ki,-659.0_ki/342720.0_ki, &
&-2207.0_ki/23040.0_ki,2789.0_ki/28800.0_ki,-163.0_ki/5376.0_ki, &
&71.0_ki/50688.0_ki,0.0_ki,0.0_ki,1693.0_ki/11520.0_ki,-17.0_ki/120.0_ki, &
&183.0_ki/4480.0_ki,-71.0_ki/42240.0_ki,0.0_ki,-2525.0_ki/32256.0_ki, &
&79.0_ki/1120.0_ki,-223.0_ki/12544.0_ki,71.0_ki/118272.0_ki, &
&163.0_ki/12672.0_ki,-193.0_ki/21120.0_ki,5.0_ki/4928.0_ki,-59.0_ki/18720.0_ki, &
&59.0_ki/31200.0_ki,0.0_ki,19.0_ki/2304.0_ki,-43.0_ki/3840.0_ki, &
&53.0_ki/10752.0_ki,-5.0_ki/16896.0_ki,0.0_ki,0.0_ki,-43.0_ki/3840.0_ki, &
&3.0_ki/200.0_ki,-29.0_ki/4480.0_ki,1.0_ki/2816.0_ki,0.0_ki,53.0_ki/10752.0_ki, &
&-29.0_ki/4480.0_ki,17.0_ki/6272.0_ki,-5.0_ki/39424.0_ki,-5.0_ki/16896.0_ki, &
&1.0_ki/2816.0_ki,-5.0_ki/39424.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/4608.0_ki, &
&1.0_ki/2880.0_ki,-1.0_ki/5376.0_ki,1.0_ki/50688.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/3840.0_ki,-1.0_ki/2400.0_ki,1.0_ki/4480.0_ki,-1.0_ki/42240.0_ki,0.0_ki, &
&-1.0_ki/10752.0_ki,1.0_ki/6720.0_ki,-1.0_ki/12544.0_ki,1.0_ki/118272.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-599.0_ki/23040.0_ki, &
&61.0_ki/6400.0_ki,-5.0_ki/3584.0_ki,0.0_ki,0.0_ki,0.0_ki,887.0_ki/17280.0_ki, &
&-27.0_ki/1600.0_ki,1.0_ki/448.0_ki,0.0_ki,0.0_ki,-991.0_ki/26880.0_ki, &
&47.0_ki/4480.0_ki,-15.0_ki/12544.0_ki,0.0_ki,2033.0_ki/152064.0_ki, &
&-3.0_ki/1280.0_ki,5.0_ki/39424.0_ki,-139.0_ki/24960.0_ki,1.0_ki/1600.0_ki, &
&41.0_ki/146880.0_ki,7.0_ki/1440.0_ki,-19.0_ki/4800.0_ki,1.0_ki/1344.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-5.0_ki/576.0_ki,11.0_ki/1600.0_ki,-1.0_ki/840.0_ki, &
&0.0_ki,0.0_ki,11.0_ki/2016.0_ki,-1.0_ki/240.0_ki,1.0_ki/1568.0_ki,0.0_ki, &
&-1.0_ki/792.0_ki,3.0_ki/3520.0_ki,-1.0_ki/14784.0_ki,1.0_ki/2880.0_ki, &
&-1.0_ki/4800.0_ki,0.0_ki,-1.0_ki/4608.0_ki,1.0_ki/3840.0_ki, &
&-1.0_ki/10752.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/2880.0_ki,-1.0_ki/2400.0_ki, &
&1.0_ki/6720.0_ki,0.0_ki,0.0_ki,-1.0_ki/5376.0_ki,1.0_ki/4480.0_ki, &
&-1.0_ki/12544.0_ki,0.0_ki,1.0_ki/50688.0_ki,-1.0_ki/42240.0_ki, &
&1.0_ki/118272.0_ki,0.0_ki,0.0_ki,0.0_ki,37.0_ki/40320.0_ki,-1.0_ki/6400.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-23.0_ki/11520.0_ki,1.0_ki/3200.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/630.0_ki,-1.0_ki/4480.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1408.0_ki,1.0_ki/14080.0_ki,0.0_ki,49.0_ki/149760.0_ki, &
&-1.0_ki/41600.0_ki,-13.0_ki/685440.0_ki,-1.0_ki/11520.0_ki,1.0_ki/19200.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/5760.0_ki,-1.0_ki/9600.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/8064.0_ki,1.0_ki/13440.0_ki,0.0_ki,0.0_ki,1.0_ki/25344.0_ki, &
&-1.0_ki/42240.0_ki,0.0_ki,-1.0_ki/74880.0_ki,1.0_ki/124800.0_ki,0.0_ki, &
&-1.0_ki/80640.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/34560.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/40320.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/76032.0_ki,0.0_ki,0.0_ki,-1.0_ki/149760.0_ki,0.0_ki, &
&1.0_ki/2056320.0_ki/),&
& (/21,21/), order=(/2,1/))
real(ki), dimension(21,2), parameter, private :: q7_2 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,11.0_ki,3.0_ki,13.0_ki, &
&3.0_ki,17.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki,5.0_ki,7.0_ki,5.0_ki,11.0_ki, &
&5.0_ki,13.0_ki,7.0_ki,3.0_ki,7.0_ki,5.0_ki,7.0_ki,7.0_ki,7.0_ki,11.0_ki, &
&11.0_ki,3.0_ki,11.0_ki,5.0_ki,11.0_ki,7.0_ki,13.0_ki,3.0_ki,13.0_ki,5.0_ki, &
&17.0_ki,3.0_ki/),&
& (/21,2/), order=(/2,1/))
real(ki), dimension(35,35), parameter, private :: mat7_3 = &
& reshape((/&
&11063.0_ki/3456.0_ki,-143.0_ki/72.0_ki,2425.0_ki/4032.0_ki, &
&-665.0_ki/12672.0_ki,77.0_ki/7488.0_ki,-143.0_ki/72.0_ki,139.0_ki/160.0_ki, &
&-81.0_ki/448.0_ki,7.0_ki/1408.0_ki,2425.0_ki/4032.0_ki,-81.0_ki/448.0_ki, &
&75.0_ki/3136.0_ki,-665.0_ki/12672.0_ki,7.0_ki/1408.0_ki,77.0_ki/7488.0_ki, &
&-143.0_ki/72.0_ki,139.0_ki/160.0_ki,-81.0_ki/448.0_ki,7.0_ki/1408.0_ki, &
&139.0_ki/160.0_ki,-459.0_ki/2000.0_ki,27.0_ki/1120.0_ki,-81.0_ki/448.0_ki, &
&27.0_ki/1120.0_ki,7.0_ki/1408.0_ki,2425.0_ki/4032.0_ki,-81.0_ki/448.0_ki, &
&75.0_ki/3136.0_ki,-81.0_ki/448.0_ki,27.0_ki/1120.0_ki,75.0_ki/3136.0_ki, &
&-665.0_ki/12672.0_ki,7.0_ki/1408.0_ki,7.0_ki/1408.0_ki,77.0_ki/7488.0_ki, &
&-337.0_ki/360.0_ki,8813.0_ki/8640.0_ki,-2255.0_ki/6048.0_ki, &
&727.0_ki/19008.0_ki,-443.0_ki/56160.0_ki,2473.0_ki/5760.0_ki, &
&-947.0_ki/2400.0_ki,33.0_ki/320.0_ki,-71.0_ki/21120.0_ki,-125.0_ki/1344.0_ki, &
&33.0_ki/448.0_ki,-5.0_ki/392.0_ki,35.0_ki/12672.0_ki,-7.0_ki/4224.0_ki,0.0_ki, &
&2473.0_ki/5760.0_ki,-947.0_ki/2400.0_ki,33.0_ki/320.0_ki,-71.0_ki/21120.0_ki, &
&-3.0_ki/25.0_ki,9.0_ki/100.0_ki,-9.0_ki/700.0_ki,3.0_ki/224.0_ki, &
&-9.0_ki/1120.0_ki,0.0_ki,-125.0_ki/1344.0_ki,33.0_ki/448.0_ki, &
&-5.0_ki/392.0_ki,3.0_ki/224.0_ki,-9.0_ki/1120.0_ki,0.0_ki,35.0_ki/12672.0_ki, &
&-7.0_ki/4224.0_ki,0.0_ki,0.0_ki,409.0_ki/4320.0_ki,-299.0_ki/2160.0_ki, &
&209.0_ki/3024.0_ki,-89.0_ki/9504.0_ki,59.0_ki/28080.0_ki,-11.0_ki/384.0_ki, &
&3.0_ki/80.0_ki,-1.0_ki/64.0_ki,1.0_ki/1408.0_ki,5.0_ki/1344.0_ki, &
&-1.0_ki/224.0_ki,5.0_ki/3136.0_ki,0.0_ki,0.0_ki,0.0_ki,-11.0_ki/384.0_ki, &
&3.0_ki/80.0_ki,-1.0_ki/64.0_ki,1.0_ki/1408.0_ki,3.0_ki/800.0_ki, &
&-9.0_ki/2000.0_ki,9.0_ki/5600.0_ki,0.0_ki,0.0_ki,0.0_ki,5.0_ki/1344.0_ki, &
&-1.0_ki/224.0_ki,5.0_ki/3136.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-11.0_ki/2880.0_ki,29.0_ki/4320.0_ki,-25.0_ki/6048.0_ki, &
&17.0_ki/19008.0_ki,-1.0_ki/4320.0_ki,1.0_ki/1920.0_ki,-1.0_ki/1200.0_ki, &
&1.0_ki/2240.0_ki,-1.0_ki/21120.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1920.0_ki,-1.0_ki/1200.0_ki,1.0_ki/2240.0_ki,-1.0_ki/21120.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/17280.0_ki,-1.0_ki/8640.0_ki, &
&1.0_ki/12096.0_ki,-1.0_ki/38016.0_ki,1.0_ki/112320.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-337.0_ki/360.0_ki,2473.0_ki/5760.0_ki, &
&-125.0_ki/1344.0_ki,35.0_ki/12672.0_ki,0.0_ki,8813.0_ki/8640.0_ki, &
&-947.0_ki/2400.0_ki,33.0_ki/448.0_ki,-7.0_ki/4224.0_ki,-2255.0_ki/6048.0_ki, &
&33.0_ki/320.0_ki,-5.0_ki/392.0_ki,727.0_ki/19008.0_ki,-71.0_ki/21120.0_ki, &
&-443.0_ki/56160.0_ki,2473.0_ki/5760.0_ki,-3.0_ki/25.0_ki,3.0_ki/224.0_ki, &
&0.0_ki,-947.0_ki/2400.0_ki,9.0_ki/100.0_ki,-9.0_ki/1120.0_ki,33.0_ki/320.0_ki, &
&-9.0_ki/700.0_ki,-71.0_ki/21120.0_ki,-125.0_ki/1344.0_ki,3.0_ki/224.0_ki, &
&0.0_ki,33.0_ki/448.0_ki,-9.0_ki/1120.0_ki,-5.0_ki/392.0_ki,35.0_ki/12672.0_ki, &
&0.0_ki,-7.0_ki/4224.0_ki,0.0_ki,365.0_ki/1728.0_ki,-3409.0_ki/17280.0_ki, &
&215.0_ki/4032.0_ki,-71.0_ki/38016.0_ki,0.0_ki,-3409.0_ki/17280.0_ki, &
&1253.0_ki/7200.0_ki,-93.0_ki/2240.0_ki,71.0_ki/63360.0_ki,215.0_ki/4032.0_ki, &
&-93.0_ki/2240.0_ki,1.0_ki/147.0_ki,-71.0_ki/38016.0_ki,71.0_ki/63360.0_ki, &
&0.0_ki,-1.0_ki/16.0_ki,19.0_ki/400.0_ki,-1.0_ki/140.0_ki,0.0_ki, &
&19.0_ki/400.0_ki,-69.0_ki/2000.0_ki,3.0_ki/700.0_ki,-1.0_ki/140.0_ki, &
&3.0_ki/700.0_ki,0.0_ki,5.0_ki/672.0_ki,-1.0_ki/224.0_ki,0.0_ki, &
&-1.0_ki/224.0_ki,3.0_ki/1120.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/1152.0_ki,7.0_ki/360.0_ki,-11.0_ki/1344.0_ki,5.0_ki/12672.0_ki, &
&0.0_ki,67.0_ki/5760.0_ki,-3.0_ki/200.0_ki,41.0_ki/6720.0_ki,-1.0_ki/4224.0_ki, &
&-1.0_ki/504.0_ki,1.0_ki/420.0_ki,-1.0_ki/1176.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/480.0_ki,-1.0_ki/400.0_ki,1.0_ki/1120.0_ki,0.0_ki,-1.0_ki/800.0_ki, &
&3.0_ki/2000.0_ki,-3.0_ki/5600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/3456.0_ki, &
&-1.0_ki/2160.0_ki,1.0_ki/4032.0_ki,-1.0_ki/38016.0_ki,0.0_ki, &
&-1.0_ki/5760.0_ki,1.0_ki/3600.0_ki,-1.0_ki/6720.0_ki,1.0_ki/63360.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,409.0_ki/4320.0_ki,-11.0_ki/384.0_ki,5.0_ki/1344.0_ki, &
&0.0_ki,0.0_ki,-299.0_ki/2160.0_ki,3.0_ki/80.0_ki,-1.0_ki/224.0_ki,0.0_ki, &
&209.0_ki/3024.0_ki,-1.0_ki/64.0_ki,5.0_ki/3136.0_ki,-89.0_ki/9504.0_ki, &
&1.0_ki/1408.0_ki,59.0_ki/28080.0_ki,-11.0_ki/384.0_ki,3.0_ki/800.0_ki,0.0_ki, &
&0.0_ki,3.0_ki/80.0_ki,-9.0_ki/2000.0_ki,0.0_ki,-1.0_ki/64.0_ki, &
&9.0_ki/5600.0_ki,1.0_ki/1408.0_ki,5.0_ki/1344.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/224.0_ki,0.0_ki,5.0_ki/3136.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/1152.0_ki,67.0_ki/5760.0_ki,-1.0_ki/504.0_ki,0.0_ki,0.0_ki, &
&7.0_ki/360.0_ki,-3.0_ki/200.0_ki,1.0_ki/420.0_ki,0.0_ki,-11.0_ki/1344.0_ki, &
&41.0_ki/6720.0_ki,-1.0_ki/1176.0_ki,5.0_ki/12672.0_ki,-1.0_ki/4224.0_ki, &
&0.0_ki,1.0_ki/480.0_ki,-1.0_ki/800.0_ki,0.0_ki,0.0_ki,-1.0_ki/400.0_ki, &
&3.0_ki/2000.0_ki,0.0_ki,1.0_ki/1120.0_ki,-3.0_ki/5600.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1728.0_ki,-1.0_ki/1440.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1440.0_ki,1.0_ki/1200.0_ki,-1.0_ki/3360.0_ki,0.0_ki,1.0_ki/4032.0_ki, &
&-1.0_ki/3360.0_ki,1.0_ki/9408.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-11.0_ki/2880.0_ki,1.0_ki/1920.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,29.0_ki/4320.0_ki,-1.0_ki/1200.0_ki,0.0_ki,0.0_ki, &
&-25.0_ki/6048.0_ki,1.0_ki/2240.0_ki,0.0_ki,17.0_ki/19008.0_ki, &
&-1.0_ki/21120.0_ki,-1.0_ki/4320.0_ki,1.0_ki/1920.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1200.0_ki,0.0_ki,0.0_ki,1.0_ki/2240.0_ki,0.0_ki,-1.0_ki/21120.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/3456.0_ki,-1.0_ki/5760.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/2160.0_ki, &
&1.0_ki/3600.0_ki,0.0_ki,0.0_ki,1.0_ki/4032.0_ki,-1.0_ki/6720.0_ki,0.0_ki, &
&-1.0_ki/38016.0_ki,1.0_ki/63360.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/17280.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/8640.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/12096.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/38016.0_ki,0.0_ki,1.0_ki/112320.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-337.0_ki/360.0_ki,2473.0_ki/5760.0_ki, &
&-125.0_ki/1344.0_ki,35.0_ki/12672.0_ki,0.0_ki,2473.0_ki/5760.0_ki, &
&-3.0_ki/25.0_ki,3.0_ki/224.0_ki,0.0_ki,-125.0_ki/1344.0_ki,3.0_ki/224.0_ki, &
&0.0_ki,35.0_ki/12672.0_ki,0.0_ki,0.0_ki,8813.0_ki/8640.0_ki, &
&-947.0_ki/2400.0_ki,33.0_ki/448.0_ki,-7.0_ki/4224.0_ki,-947.0_ki/2400.0_ki, &
&9.0_ki/100.0_ki,-9.0_ki/1120.0_ki,33.0_ki/448.0_ki,-9.0_ki/1120.0_ki, &
&-7.0_ki/4224.0_ki,-2255.0_ki/6048.0_ki,33.0_ki/320.0_ki,-5.0_ki/392.0_ki, &
&33.0_ki/320.0_ki,-9.0_ki/700.0_ki,-5.0_ki/392.0_ki,727.0_ki/19008.0_ki, &
&-71.0_ki/21120.0_ki,-71.0_ki/21120.0_ki,-443.0_ki/56160.0_ki, &
&365.0_ki/1728.0_ki,-3409.0_ki/17280.0_ki,215.0_ki/4032.0_ki, &
&-71.0_ki/38016.0_ki,0.0_ki,-1.0_ki/16.0_ki,19.0_ki/400.0_ki,-1.0_ki/140.0_ki, &
&0.0_ki,5.0_ki/672.0_ki,-1.0_ki/224.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-3409.0_ki/17280.0_ki,1253.0_ki/7200.0_ki,-93.0_ki/2240.0_ki, &
&71.0_ki/63360.0_ki,19.0_ki/400.0_ki,-69.0_ki/2000.0_ki,3.0_ki/700.0_ki, &
&-1.0_ki/224.0_ki,3.0_ki/1120.0_ki,0.0_ki,215.0_ki/4032.0_ki, &
&-93.0_ki/2240.0_ki,1.0_ki/147.0_ki,-1.0_ki/140.0_ki,3.0_ki/700.0_ki,0.0_ki, &
&-71.0_ki/38016.0_ki,71.0_ki/63360.0_ki,0.0_ki,0.0_ki,-17.0_ki/1152.0_ki, &
&7.0_ki/360.0_ki,-11.0_ki/1344.0_ki,5.0_ki/12672.0_ki,0.0_ki,1.0_ki/480.0_ki, &
&-1.0_ki/400.0_ki,1.0_ki/1120.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,67.0_ki/5760.0_ki,-3.0_ki/200.0_ki,41.0_ki/6720.0_ki,-1.0_ki/4224.0_ki, &
&-1.0_ki/800.0_ki,3.0_ki/2000.0_ki,-3.0_ki/5600.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/504.0_ki,1.0_ki/420.0_ki,-1.0_ki/1176.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/3456.0_ki,-1.0_ki/2160.0_ki, &
&1.0_ki/4032.0_ki,-1.0_ki/38016.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/5760.0_ki,1.0_ki/3600.0_ki, &
&-1.0_ki/6720.0_ki,1.0_ki/63360.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&365.0_ki/1728.0_ki,-1.0_ki/16.0_ki,5.0_ki/672.0_ki,0.0_ki,0.0_ki, &
&-3409.0_ki/17280.0_ki,19.0_ki/400.0_ki,-1.0_ki/224.0_ki,0.0_ki, &
&215.0_ki/4032.0_ki,-1.0_ki/140.0_ki,0.0_ki,-71.0_ki/38016.0_ki,0.0_ki,0.0_ki, &
&-3409.0_ki/17280.0_ki,19.0_ki/400.0_ki,-1.0_ki/224.0_ki,0.0_ki, &
&1253.0_ki/7200.0_ki,-69.0_ki/2000.0_ki,3.0_ki/1120.0_ki,-93.0_ki/2240.0_ki, &
&3.0_ki/700.0_ki,71.0_ki/63360.0_ki,215.0_ki/4032.0_ki,-1.0_ki/140.0_ki,0.0_ki, &
&-93.0_ki/2240.0_ki,3.0_ki/700.0_ki,1.0_ki/147.0_ki,-71.0_ki/38016.0_ki,0.0_ki, &
&71.0_ki/63360.0_ki,0.0_ki,-7.0_ki/216.0_ki,1.0_ki/40.0_ki,-1.0_ki/252.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/40.0_ki,-11.0_ki/600.0_ki,1.0_ki/420.0_ki,0.0_ki, &
&-1.0_ki/252.0_ki,1.0_ki/420.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/40.0_ki, &
&-11.0_ki/600.0_ki,1.0_ki/420.0_ki,0.0_ki,-11.0_ki/600.0_ki,13.0_ki/1000.0_ki, &
&-1.0_ki/700.0_ki,1.0_ki/420.0_ki,-1.0_ki/700.0_ki,0.0_ki,-1.0_ki/252.0_ki, &
&1.0_ki/420.0_ki,0.0_ki,1.0_ki/420.0_ki,-1.0_ki/700.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/864.0_ki,-1.0_ki/720.0_ki,1.0_ki/2016.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1440.0_ki,1.0_ki/1200.0_ki,-1.0_ki/3360.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1440.0_ki,1.0_ki/1200.0_ki, &
&-1.0_ki/3360.0_ki,0.0_ki,1.0_ki/2400.0_ki,-1.0_ki/2000.0_ki,1.0_ki/5600.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-17.0_ki/1152.0_ki,1.0_ki/480.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&7.0_ki/360.0_ki,-1.0_ki/400.0_ki,0.0_ki,0.0_ki,-11.0_ki/1344.0_ki, &
&1.0_ki/1120.0_ki,0.0_ki,5.0_ki/12672.0_ki,0.0_ki,0.0_ki,67.0_ki/5760.0_ki, &
&-1.0_ki/800.0_ki,0.0_ki,0.0_ki,-3.0_ki/200.0_ki,3.0_ki/2000.0_ki,0.0_ki, &
&41.0_ki/6720.0_ki,-3.0_ki/5600.0_ki,-1.0_ki/4224.0_ki,-1.0_ki/504.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/420.0_ki,0.0_ki,-1.0_ki/1176.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/864.0_ki,-1.0_ki/1440.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/720.0_ki, &
&1.0_ki/1200.0_ki,0.0_ki,0.0_ki,1.0_ki/2016.0_ki,-1.0_ki/3360.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1440.0_ki,1.0_ki/2400.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1200.0_ki,-1.0_ki/2000.0_ki,0.0_ki,-1.0_ki/3360.0_ki,1.0_ki/5600.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/3456.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/2160.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki,-1.0_ki/38016.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/5760.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/3600.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/6720.0_ki,0.0_ki,1.0_ki/63360.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,409.0_ki/4320.0_ki,-11.0_ki/384.0_ki, &
&5.0_ki/1344.0_ki,0.0_ki,0.0_ki,-11.0_ki/384.0_ki,3.0_ki/800.0_ki,0.0_ki, &
&0.0_ki,5.0_ki/1344.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-299.0_ki/2160.0_ki,3.0_ki/80.0_ki,-1.0_ki/224.0_ki,0.0_ki,3.0_ki/80.0_ki, &
&-9.0_ki/2000.0_ki,0.0_ki,-1.0_ki/224.0_ki,0.0_ki,0.0_ki,209.0_ki/3024.0_ki, &
&-1.0_ki/64.0_ki,5.0_ki/3136.0_ki,-1.0_ki/64.0_ki,9.0_ki/5600.0_ki, &
&5.0_ki/3136.0_ki,-89.0_ki/9504.0_ki,1.0_ki/1408.0_ki,1.0_ki/1408.0_ki, &
&59.0_ki/28080.0_ki,-17.0_ki/1152.0_ki,67.0_ki/5760.0_ki,-1.0_ki/504.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/480.0_ki,-1.0_ki/800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,7.0_ki/360.0_ki,-3.0_ki/200.0_ki,1.0_ki/420.0_ki, &
&0.0_ki,-1.0_ki/400.0_ki,3.0_ki/2000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-11.0_ki/1344.0_ki,41.0_ki/6720.0_ki,-1.0_ki/1176.0_ki,1.0_ki/1120.0_ki, &
&-3.0_ki/5600.0_ki,0.0_ki,5.0_ki/12672.0_ki,-1.0_ki/4224.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1728.0_ki,-1.0_ki/1440.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1440.0_ki,1.0_ki/1200.0_ki,-1.0_ki/3360.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/4032.0_ki,-1.0_ki/3360.0_ki, &
&1.0_ki/9408.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-17.0_ki/1152.0_ki,1.0_ki/480.0_ki,0.0_ki,0.0_ki,0.0_ki,67.0_ki/5760.0_ki, &
&-1.0_ki/800.0_ki,0.0_ki,0.0_ki,-1.0_ki/504.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,7.0_ki/360.0_ki,-1.0_ki/400.0_ki,0.0_ki,0.0_ki,-3.0_ki/200.0_ki, &
&3.0_ki/2000.0_ki,0.0_ki,1.0_ki/420.0_ki,0.0_ki,0.0_ki,-11.0_ki/1344.0_ki, &
&1.0_ki/1120.0_ki,0.0_ki,41.0_ki/6720.0_ki,-3.0_ki/5600.0_ki,-1.0_ki/1176.0_ki, &
&5.0_ki/12672.0_ki,0.0_ki,-1.0_ki/4224.0_ki,0.0_ki,1.0_ki/864.0_ki, &
&-1.0_ki/1440.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1440.0_ki,1.0_ki/2400.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/720.0_ki, &
&1.0_ki/1200.0_ki,0.0_ki,0.0_ki,1.0_ki/1200.0_ki,-1.0_ki/2000.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/2016.0_ki,-1.0_ki/3360.0_ki,0.0_ki, &
&-1.0_ki/3360.0_ki,1.0_ki/5600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1728.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1440.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1440.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/1200.0_ki,0.0_ki,0.0_ki,-1.0_ki/3360.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/4032.0_ki,0.0_ki,0.0_ki,-1.0_ki/3360.0_ki,0.0_ki, &
&1.0_ki/9408.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-11.0_ki/2880.0_ki, &
&1.0_ki/1920.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1920.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,29.0_ki/4320.0_ki,-1.0_ki/1200.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/1200.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-25.0_ki/6048.0_ki,1.0_ki/2240.0_ki,0.0_ki,1.0_ki/2240.0_ki,0.0_ki,0.0_ki, &
&17.0_ki/19008.0_ki,-1.0_ki/21120.0_ki,-1.0_ki/21120.0_ki,-1.0_ki/4320.0_ki, &
&1.0_ki/3456.0_ki,-1.0_ki/5760.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/2160.0_ki, &
&1.0_ki/3600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/4032.0_ki,-1.0_ki/6720.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/38016.0_ki,1.0_ki/63360.0_ki,0.0_ki,0.0_ki,1.0_ki/3456.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-1.0_ki/5760.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/2160.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/3600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/4032.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/6720.0_ki,0.0_ki,0.0_ki,-1.0_ki/38016.0_ki,0.0_ki, &
&1.0_ki/63360.0_ki,0.0_ki,1.0_ki/17280.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/8640.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/12096.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/38016.0_ki,0.0_ki,0.0_ki,1.0_ki/112320.0_ki/),&
& (/35,35/), order=(/2,1/))
real(ki), dimension(35,3), parameter, private :: q7_3 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki, &
&11.0_ki,3.0_ki,3.0_ki,13.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki, &
&3.0_ki,5.0_ki,7.0_ki,3.0_ki,5.0_ki,11.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki,7.0_ki, &
&5.0_ki,3.0_ki,7.0_ki,7.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki,11.0_ki,5.0_ki, &
&3.0_ki,13.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki, &
&7.0_ki,5.0_ki,3.0_ki,11.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,5.0_ki,5.0_ki,5.0_ki, &
&5.0_ki,7.0_ki,5.0_ki,7.0_ki,3.0_ki,5.0_ki,7.0_ki,5.0_ki,5.0_ki,11.0_ki,3.0_ki, &
&7.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki,7.0_ki,7.0_ki,5.0_ki, &
&3.0_ki,7.0_ki,5.0_ki,5.0_ki,7.0_ki,7.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki, &
&11.0_ki,3.0_ki,5.0_ki,11.0_ki,5.0_ki,3.0_ki,13.0_ki,3.0_ki,3.0_ki/),&
& (/35,3/), order=(/2,1/))
real(ki), dimension(35,35), parameter, private :: mat7_4 = &
& reshape((/&
&1309.0_ki/1296.0_ki,-829.0_ki/2160.0_ki,145.0_ki/2016.0_ki, &
&-35.0_ki/19008.0_ki,-829.0_ki/2160.0_ki,9.0_ki/100.0_ki,-1.0_ki/112.0_ki, &
&145.0_ki/2016.0_ki,-1.0_ki/112.0_ki,-35.0_ki/19008.0_ki,-829.0_ki/2160.0_ki, &
&9.0_ki/100.0_ki,-1.0_ki/112.0_ki,9.0_ki/100.0_ki,-9.0_ki/1000.0_ki, &
&-1.0_ki/112.0_ki,145.0_ki/2016.0_ki,-1.0_ki/112.0_ki,-1.0_ki/112.0_ki, &
&-35.0_ki/19008.0_ki,-829.0_ki/2160.0_ki,9.0_ki/100.0_ki,-1.0_ki/112.0_ki, &
&9.0_ki/100.0_ki,-9.0_ki/1000.0_ki,-1.0_ki/112.0_ki,9.0_ki/100.0_ki, &
&-9.0_ki/1000.0_ki,-9.0_ki/1000.0_ki,-1.0_ki/112.0_ki,145.0_ki/2016.0_ki, &
&-1.0_ki/112.0_ki,-1.0_ki/112.0_ki,-1.0_ki/112.0_ki,-35.0_ki/19008.0_ki, &
&-995.0_ki/5184.0_ki,1099.0_ki/6480.0_ki,-247.0_ki/6048.0_ki, &
&71.0_ki/57024.0_ki,17.0_ki/360.0_ki,-7.0_ki/200.0_ki,1.0_ki/210.0_ki, &
&-5.0_ki/1008.0_ki,1.0_ki/336.0_ki,0.0_ki,17.0_ki/360.0_ki,-7.0_ki/200.0_ki, &
&1.0_ki/210.0_ki,-1.0_ki/200.0_ki,3.0_ki/1000.0_ki,0.0_ki,-5.0_ki/1008.0_ki, &
&1.0_ki/336.0_ki,0.0_ki,0.0_ki,17.0_ki/360.0_ki,-7.0_ki/200.0_ki, &
&1.0_ki/210.0_ki,-1.0_ki/200.0_ki,3.0_ki/1000.0_ki,0.0_ki,-1.0_ki/200.0_ki, &
&3.0_ki/1000.0_ki,0.0_ki,0.0_ki,-5.0_ki/1008.0_ki,1.0_ki/336.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,59.0_ki/5184.0_ki,-2.0_ki/135.0_ki,37.0_ki/6048.0_ki, &
&-5.0_ki/19008.0_ki,-1.0_ki/720.0_ki,1.0_ki/600.0_ki,-1.0_ki/1680.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/720.0_ki,1.0_ki/600.0_ki,-1.0_ki/1680.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/720.0_ki,1.0_ki/600.0_ki, &
&-1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/5184.0_ki,1.0_ki/3240.0_ki, &
&-1.0_ki/6048.0_ki,1.0_ki/57024.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-995.0_ki/5184.0_ki,17.0_ki/360.0_ki,-5.0_ki/1008.0_ki, &
&0.0_ki,1099.0_ki/6480.0_ki,-7.0_ki/200.0_ki,1.0_ki/336.0_ki, &
&-247.0_ki/6048.0_ki,1.0_ki/210.0_ki,71.0_ki/57024.0_ki,17.0_ki/360.0_ki, &
&-1.0_ki/200.0_ki,0.0_ki,-7.0_ki/200.0_ki,3.0_ki/1000.0_ki,1.0_ki/210.0_ki, &
&-5.0_ki/1008.0_ki,0.0_ki,1.0_ki/336.0_ki,0.0_ki,17.0_ki/360.0_ki, &
&-1.0_ki/200.0_ki,0.0_ki,-7.0_ki/200.0_ki,3.0_ki/1000.0_ki,1.0_ki/210.0_ki, &
&-1.0_ki/200.0_ki,0.0_ki,3.0_ki/1000.0_ki,0.0_ki,-5.0_ki/1008.0_ki,0.0_ki, &
&1.0_ki/336.0_ki,0.0_ki,0.0_ki,2.0_ki/81.0_ki,-1.0_ki/54.0_ki,1.0_ki/378.0_ki, &
&0.0_ki,-1.0_ki/54.0_ki,1.0_ki/75.0_ki,-1.0_ki/630.0_ki,1.0_ki/378.0_ki, &
&-1.0_ki/630.0_ki,0.0_ki,-1.0_ki/360.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&1.0_ki/600.0_ki,-1.0_ki/1000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/360.0_ki,1.0_ki/600.0_ki,0.0_ki,1.0_ki/600.0_ki,-1.0_ki/1000.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1296.0_ki,1.0_ki/1080.0_ki,-1.0_ki/3024.0_ki,0.0_ki,1.0_ki/2160.0_ki, &
&-1.0_ki/1800.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&59.0_ki/5184.0_ki,-1.0_ki/720.0_ki,0.0_ki,0.0_ki,-2.0_ki/135.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,37.0_ki/6048.0_ki,-1.0_ki/1680.0_ki,-5.0_ki/19008.0_ki, &
&-1.0_ki/720.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki,-1.0_ki/1680.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/720.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki, &
&0.0_ki,-1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/1296.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki,0.0_ki,-1.0_ki/3024.0_ki,1.0_ki/5040.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/5184.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/3240.0_ki,0.0_ki,0.0_ki,-1.0_ki/6048.0_ki,0.0_ki,1.0_ki/57024.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-995.0_ki/5184.0_ki,17.0_ki/360.0_ki,-5.0_ki/1008.0_ki, &
&0.0_ki,17.0_ki/360.0_ki,-1.0_ki/200.0_ki,0.0_ki,-5.0_ki/1008.0_ki,0.0_ki, &
&0.0_ki,1099.0_ki/6480.0_ki,-7.0_ki/200.0_ki,1.0_ki/336.0_ki,-7.0_ki/200.0_ki, &
&3.0_ki/1000.0_ki,1.0_ki/336.0_ki,-247.0_ki/6048.0_ki,1.0_ki/210.0_ki, &
&1.0_ki/210.0_ki,71.0_ki/57024.0_ki,17.0_ki/360.0_ki,-1.0_ki/200.0_ki,0.0_ki, &
&-1.0_ki/200.0_ki,0.0_ki,0.0_ki,-7.0_ki/200.0_ki,3.0_ki/1000.0_ki, &
&3.0_ki/1000.0_ki,1.0_ki/210.0_ki,-5.0_ki/1008.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/336.0_ki,0.0_ki,2.0_ki/81.0_ki,-1.0_ki/54.0_ki,1.0_ki/378.0_ki,0.0_ki, &
&-1.0_ki/360.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki, &
&1.0_ki/75.0_ki,-1.0_ki/630.0_ki,1.0_ki/600.0_ki,-1.0_ki/1000.0_ki,0.0_ki, &
&1.0_ki/378.0_ki,-1.0_ki/630.0_ki,0.0_ki,0.0_ki,-1.0_ki/360.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki,-1.0_ki/1000.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/3024.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/2160.0_ki,-1.0_ki/1800.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,2.0_ki/81.0_ki, &
&-1.0_ki/360.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&1.0_ki/378.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&1.0_ki/75.0_ki,-1.0_ki/1000.0_ki,-1.0_ki/630.0_ki,1.0_ki/378.0_ki,0.0_ki, &
&-1.0_ki/630.0_ki,0.0_ki,-1.0_ki/360.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/600.0_ki,0.0_ki,-1.0_ki/1000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/648.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki,0.0_ki,-1.0_ki/1800.0_ki,1.0_ki/3000.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1296.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/3024.0_ki,0.0_ki,0.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1800.0_ki,0.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,59.0_ki/5184.0_ki,-1.0_ki/720.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/720.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-2.0_ki/135.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki,37.0_ki/6048.0_ki, &
&-1.0_ki/1680.0_ki,-1.0_ki/1680.0_ki,-5.0_ki/19008.0_ki,-1.0_ki/720.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1680.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki, &
&1.0_ki/2160.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/3024.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1296.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/3024.0_ki,0.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/5184.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/3240.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/6048.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/57024.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-995.0_ki/5184.0_ki,17.0_ki/360.0_ki,-5.0_ki/1008.0_ki,0.0_ki, &
&17.0_ki/360.0_ki,-1.0_ki/200.0_ki,0.0_ki,-5.0_ki/1008.0_ki,0.0_ki,0.0_ki, &
&17.0_ki/360.0_ki,-1.0_ki/200.0_ki,0.0_ki,-1.0_ki/200.0_ki,0.0_ki,0.0_ki, &
&-5.0_ki/1008.0_ki,0.0_ki,0.0_ki,0.0_ki,1099.0_ki/6480.0_ki,-7.0_ki/200.0_ki, &
&1.0_ki/336.0_ki,-7.0_ki/200.0_ki,3.0_ki/1000.0_ki,1.0_ki/336.0_ki, &
&-7.0_ki/200.0_ki,3.0_ki/1000.0_ki,3.0_ki/1000.0_ki,1.0_ki/336.0_ki, &
&-247.0_ki/6048.0_ki,1.0_ki/210.0_ki,1.0_ki/210.0_ki,1.0_ki/210.0_ki, &
&71.0_ki/57024.0_ki,2.0_ki/81.0_ki,-1.0_ki/54.0_ki,1.0_ki/378.0_ki,0.0_ki, &
&-1.0_ki/360.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/360.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/54.0_ki,1.0_ki/75.0_ki,-1.0_ki/630.0_ki,1.0_ki/600.0_ki, &
&-1.0_ki/1000.0_ki,0.0_ki,1.0_ki/600.0_ki,-1.0_ki/1000.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/378.0_ki,-1.0_ki/630.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/3024.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/2160.0_ki,-1.0_ki/1800.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,2.0_ki/81.0_ki, &
&-1.0_ki/360.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&1.0_ki/378.0_ki,0.0_ki,0.0_ki,-1.0_ki/360.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki, &
&0.0_ki,1.0_ki/75.0_ki,-1.0_ki/1000.0_ki,-1.0_ki/630.0_ki,1.0_ki/600.0_ki, &
&0.0_ki,-1.0_ki/1000.0_ki,0.0_ki,1.0_ki/378.0_ki,0.0_ki,-1.0_ki/630.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/648.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki, &
&-1.0_ki/1800.0_ki,0.0_ki,-1.0_ki/1800.0_ki,1.0_ki/3000.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,-1.0_ki/3024.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/2160.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,1.0_ki/5040.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,2.0_ki/81.0_ki, &
&-1.0_ki/360.0_ki,0.0_ki,0.0_ki,-1.0_ki/360.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/378.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/54.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,0.0_ki,1.0_ki/75.0_ki,-1.0_ki/1000.0_ki, &
&-1.0_ki/1000.0_ki,-1.0_ki/630.0_ki,1.0_ki/378.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/630.0_ki,0.0_ki,-1.0_ki/648.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,-1.0_ki/1800.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki, &
&-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki, &
&1.0_ki/3000.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/648.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,1.0_ki/3000.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,-1.0_ki/3024.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,1.0_ki/5040.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,59.0_ki/5184.0_ki,-1.0_ki/720.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/720.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/720.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,-2.0_ki/135.0_ki, &
&1.0_ki/600.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki,0.0_ki,1.0_ki/600.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,37.0_ki/6048.0_ki,-1.0_ki/1680.0_ki,-1.0_ki/1680.0_ki, &
&-1.0_ki/1680.0_ki,-5.0_ki/19008.0_ki,-1.0_ki/1296.0_ki,1.0_ki/2160.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,1.0_ki/1080.0_ki, &
&-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/3024.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/1296.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/1080.0_ki,0.0_ki,0.0_ki,-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,-1.0_ki/3024.0_ki,0.0_ki,1.0_ki/5040.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1296.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,1.0_ki/2160.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,1.0_ki/1080.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&-1.0_ki/1800.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/3024.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/5040.0_ki,0.0_ki,-1.0_ki/5184.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,1.0_ki/3240.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&0.0_ki,0.0_ki,0.0_ki,0.0_ki,-1.0_ki/6048.0_ki,0.0_ki,0.0_ki,0.0_ki, &
&1.0_ki/57024.0_ki/),&
& (/35,35/), order=(/2,1/))
real(ki), dimension(35,4), parameter, private :: q7_4 = &
& reshape((/&
&3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki, &
&7.0_ki,3.0_ki,3.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki, &
&5.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki, &
&3.0_ki,7.0_ki,5.0_ki,3.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki, &
&3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,5.0_ki, &
&3.0_ki,3.0_ki,5.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki,3.0_ki,7.0_ki, &
&3.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,3.0_ki,7.0_ki,5.0_ki,3.0_ki,3.0_ki, &
&11.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,3.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki, &
&5.0_ki,3.0_ki,3.0_ki,7.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki,3.0_ki,5.0_ki, &
&5.0_ki,5.0_ki,3.0_ki,7.0_ki,3.0_ki,5.0_ki,5.0_ki,3.0_ki,3.0_ki,5.0_ki,5.0_ki, &
&3.0_ki,5.0_ki,5.0_ki,5.0_ki,5.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki,3.0_ki,7.0_ki, &
&3.0_ki,3.0_ki,3.0_ki,7.0_ki,3.0_ki,3.0_ki,5.0_ki,7.0_ki,3.0_ki,5.0_ki,3.0_ki, &
&7.0_ki,5.0_ki,3.0_ki,3.0_ki,11.0_ki,3.0_ki,3.0_ki,3.0_ki/),&
& (/35,4/), order=(/2,1/))
!****t* src/interface/tens_rec/coeff_type_1
!
! NAME
!
!  Type coeff_type_1
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 1.
!
! ENTRIES
!
!  * c0, ..., c1  -- coefficients of terms with 0,...,1
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_1
   complex(ki) :: c0
   complex(ki), dimension(4,1) :: c1
end type coeff_type_1
!****t* src/interface/tens_rec/coeff_type_2
!
! NAME
!
!  Type coeff_type_2
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 2.
!
! ENTRIES
!
!  * c0, ..., c2  -- coefficients of terms with 0,...,2
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_2
   complex(ki) :: c0
   complex(ki), dimension(4,2) :: c1
   complex(ki), dimension(6,1) :: c2
end type coeff_type_2
!****t* src/interface/tens_rec/coeff_type_3
!
! NAME
!
!  Type coeff_type_3
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 3.
!
! ENTRIES
!
!  * c0, ..., c3  -- coefficients of terms with 0,...,3
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_3
   complex(ki) :: c0
   complex(ki), dimension(4,3) :: c1
   complex(ki), dimension(6,3) :: c2
   complex(ki), dimension(4,1) :: c3
end type coeff_type_3
!****t* src/interface/tens_rec/coeff_type_4
!
! NAME
!
!  Type coeff_type_4
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 4.
!
! ENTRIES
!
!  * c0, ..., c4  -- coefficients of terms with 0,...,4
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_4
   complex(ki) :: c0
   complex(ki), dimension(4,4) :: c1
   complex(ki), dimension(6,6) :: c2
   complex(ki), dimension(4,4) :: c3
   complex(ki), dimension(1,1) :: c4
end type coeff_type_4
!****t* src/interface/tens_rec/coeff_type_5
!
! NAME
!
!  Type coeff_type_5
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 5.
!
! ENTRIES
!
!  * c0, ..., c4  -- coefficients of terms with 0,...,4
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_5
   complex(ki) :: c0
   complex(ki), dimension(4,5) :: c1
   complex(ki), dimension(6,10) :: c2
   complex(ki), dimension(4,10) :: c3
   complex(ki), dimension(1,5) :: c4
end type coeff_type_5
!****t* src/interface/tens_rec/coeff_type_6
!
! NAME
!
!  Type coeff_type_6
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 6.
!
! ENTRIES
!
!  * c0, ..., c4  -- coefficients of terms with 0,...,4
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_6
   complex(ki) :: c0
   complex(ki), dimension(4,6) :: c1
   complex(ki), dimension(6,15) :: c2
   complex(ki), dimension(4,20) :: c3
   complex(ki), dimension(1,15) :: c4
end type coeff_type_6
!****t* src/interface/tens_rec/coeff_type_7
!
! NAME
!
!  Type coeff_type_7
!
! DESCRIPTION
!
!  Holds the coefficients of a mixed rank tensor integral with maximum
!  tensor rank 7.
!
! ENTRIES
!
!  * c0, ..., c4  -- coefficients of terms with 0,...,4
!                           first index selects non-zero components of q
!                           second index selects a specific monomial
!
!*****
type coeff_type_7
   complex(ki) :: c0
   complex(ki), dimension(4,7) :: c1
   complex(ki), dimension(6,21) :: c2
   complex(ki), dimension(4,35) :: c3
   complex(ki), dimension(1,35) :: c4
end type coeff_type_7
interface print_coeffs
   module procedure print_coeffs_1
   module procedure print_coeffs_2
   module procedure print_coeffs_3
   module procedure print_coeffs_4
   module procedure print_coeffs_5
   module procedure print_coeffs_6
   module procedure print_coeffs_7
end interface
contains
!****f* src/interface/tens_rec/solve1_1
! NAME
!
!  Subroutine solve1_1
!
! USAGE
!
!  call solve1_1(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q1_1.
!  The matrix mat1_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_1 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve1_1(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_1), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_3), intent(in), optional :: coeffs2
   complex(ki), dimension(1) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,1
         Q(indices(1)) = q1_1(i,1)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval1(Q, coeffs, 0) &
            & - tenseval3(Q, coeffs2, 1)
      end do
   else
      do i=1,1
         Q(indices(1)) = q1_1(i,1)
         xnum(i) = numeval(Q, mu2) - tenseval1(Q, coeffs, 0)
      end do
   end if
   coeffs%c1(idx,:) = matmul(mat1_1,xnum)
end subroutine solve1_1
!****f* src/interface/tens_rec/tenseval1_1
! NAME
!
! Function tenseval1_1
!
! USAGE
!
!  result = tenseval1_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval1_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval1_1
   real(ki) :: q0
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(1)*q0
   tenseval1_1 = acc
end  function tenseval1_1
!****f* src/interface/tens_rec/ctenseval1_1
! NAME
!
! Function ctenseval1_1
!
! USAGE
!
!  result = ctenseval1_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval1_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval1_1
   complex(ki) :: q0
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(1)*q0
   ctenseval1_1 = acc
end  function ctenseval1_1
!****f* src/interface/tens_rec/solve1
! NAME
!
! Subroutine solve1
!
! USAGE
!
!  call solve1(numeval, mu2, coeffs, coeffs2)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 1
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_1 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve1(numeval, mu2, coeffs, coeffs2)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_1), intent(inout) :: coeffs
   type(coeff_type_3), intent(in), optional :: coeffs2
   if (present(coeffs2)) then
      coeffs%c0 = numeval(null_vec, mu2) - coeffs2%c0
      call solve1_1(numeval, (/0/), mu2, coeffs, 1, coeffs2)
      call solve1_1(numeval, (/1/), mu2, coeffs, 2, coeffs2)
      call solve1_1(numeval, (/2/), mu2, coeffs, 3, coeffs2)
      call solve1_1(numeval, (/3/), mu2, coeffs, 4, coeffs2)
   else
      coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
      call solve1_1(numeval, (/0/), mu2, coeffs, 1)
      call solve1_1(numeval, (/1/), mu2, coeffs, 2)
      call solve1_1(numeval, (/2/), mu2, coeffs, 3)
      call solve1_1(numeval, (/3/), mu2, coeffs, 4)
   end if
end subroutine solve1
!****f* src/interface/tens_rec/tenseval1
! NAME
!
! Function tenseval1
!
! USAGE
!
!  result = tenseval1(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_1
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval1(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_1), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval1
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 1
   end if
   tenseval1 = coeffs%c0
   if (1 .le. maxk) then
      tenseval1 = tenseval1 + tenseval1_1(Q, (/0/), coeffs%c1(1,:))
      tenseval1 = tenseval1 + tenseval1_1(Q, (/1/), coeffs%c1(2,:))
      tenseval1 = tenseval1 + tenseval1_1(Q, (/2/), coeffs%c1(3,:))
      tenseval1 = tenseval1 + tenseval1_1(Q, (/3/), coeffs%c1(4,:))
   end if
end  function tenseval1
!****f* src/interface/tens_rec/ctenseval1
! NAME
!
! Function ctenseval1
!
! USAGE
!
!  result = ctenseval1(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_1
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval1(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_1), intent(in) :: coeffs
   complex(ki) :: ctenseval1
   ctenseval1 = coeffs%c0
   ctenseval1 = ctenseval1 + ctenseval1_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval1 = ctenseval1 + ctenseval1_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval1 = ctenseval1 + ctenseval1_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval1 = ctenseval1 + ctenseval1_1(Q, (/3/), coeffs%c1(4,:))
end  function ctenseval1
!****f* src/interface/tens_rec/print_coeffs_1
! NAME
!
! Subroutine print_coeffs_1
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 1
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_1
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_1(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_1), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
end subroutine print_coeffs_1
!****f* src/interface/tens_rec/reconstruct1
! NAME
!
! Subroutine reconstruct1
!
! USAGE
!
!  call reconstruct1(numeval, cm0)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 1,
!  including the coefficients in front of mu2 and mu2^2.
!
!  In the given case the rank is too low in order to allow for mu2 pieces.
!
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_1, representing the
!               numerator
!
! SIDE EFFECTS
!
!  Writes results to cm0.
!
! EXAMPLE
!
!
!*****
subroutine     reconstruct1(numeval, cm0)
   ! generated by: write_subroutine_reconstruct_dummy
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_1), intent(out) :: cm0
   call solve1(numeval, 0.0_ki, cm0)
end subroutine reconstruct1
!****f* src/interface/tens_rec/solve2_1
! NAME
!
!  Subroutine solve2_1
!
! USAGE
!
!  call solve2_1(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q2_1.
!  The matrix mat2_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_2 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve2_1(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_2), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_4), intent(in), optional :: coeffs2
   complex(ki), dimension(2) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,2
         Q(indices(1)) = q2_1(i,1)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval2(Q, coeffs, 0) &
            & - tenseval4(Q, coeffs2, 1)
      end do
   else
      do i=1,2
         Q(indices(1)) = q2_1(i,1)
         xnum(i) = numeval(Q, mu2) - tenseval2(Q, coeffs, 0)
      end do
   end if
   coeffs%c1(idx,:) = matmul(mat2_1,xnum)
end subroutine solve2_1
!****f* src/interface/tens_rec/tenseval2_1
! NAME
!
! Function tenseval2_1
!
! USAGE
!
!  result = tenseval2_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(2) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval2_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(2), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval2_1
   real(ki) :: q0
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(1) + coeffs(2)*q0
   acc = acc*q0
   tenseval2_1 = acc
end  function tenseval2_1
!****f* src/interface/tens_rec/ctenseval2_1
! NAME
!
! Function ctenseval2_1
!
! USAGE
!
!  result = ctenseval2_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(2) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval2_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(2), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval2_1
   complex(ki) :: q0
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(1) + coeffs(2)*q0
   acc = acc*q0
   ctenseval2_1 = acc
end  function ctenseval2_1
!****f* src/interface/tens_rec/solve2_2
! NAME
!
!  Subroutine solve2_2
!
! USAGE
!
!  call solve2_2(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q2_2.
!  The matrix mat2_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_2 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve2_2(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_2), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_4), intent(in), optional :: coeffs2
   complex(ki), dimension(1) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,1
         Q(indices(1)) = q2_2(i,1)
         Q(indices(2)) = q2_2(i,2)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval2(Q, coeffs, 1) &
            & - tenseval4(Q, coeffs2, 2)
      end do
   else
      do i=1,1
         Q(indices(1)) = q2_2(i,1)
         Q(indices(2)) = q2_2(i,2)
         xnum(i) = numeval(Q, mu2) - tenseval2(Q, coeffs, 1)
      end do
   end if
   coeffs%c2(idx,:) = matmul(mat2_2,xnum)
end subroutine solve2_2
!****f* src/interface/tens_rec/tenseval2_2
! NAME
!
! Function tenseval2_2
!
! USAGE
!
!  result = tenseval2_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval2_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval2_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(1)*q0*q1
   tenseval2_2 = acc
end  function tenseval2_2
!****f* src/interface/tens_rec/ctenseval2_2
! NAME
!
! Function ctenseval2_2
!
! USAGE
!
!  result = ctenseval2_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval2_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval2_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(1)*q0*q1
   ctenseval2_2 = acc
end  function ctenseval2_2
!****f* src/interface/tens_rec/solve2
! NAME
!
! Subroutine solve2
!
! USAGE
!
!  call solve2(numeval, mu2, coeffs, coeffs2)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 2
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_2 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve2(numeval, mu2, coeffs, coeffs2)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_2), intent(inout) :: coeffs
   type(coeff_type_4), intent(in), optional :: coeffs2
   if (present(coeffs2)) then
      coeffs%c0 = numeval(null_vec, mu2) - coeffs2%c0
      call solve2_1(numeval, (/0/), mu2, coeffs, 1, coeffs2)
      call solve2_1(numeval, (/1/), mu2, coeffs, 2, coeffs2)
      call solve2_1(numeval, (/2/), mu2, coeffs, 3, coeffs2)
      call solve2_1(numeval, (/3/), mu2, coeffs, 4, coeffs2)
      call solve2_2(numeval, (/0,1/), mu2, coeffs, 1, coeffs2)
      call solve2_2(numeval, (/0,2/), mu2, coeffs, 2, coeffs2)
      call solve2_2(numeval, (/0,3/), mu2, coeffs, 3, coeffs2)
      call solve2_2(numeval, (/1,2/), mu2, coeffs, 4, coeffs2)
      call solve2_2(numeval, (/1,3/), mu2, coeffs, 5, coeffs2)
      call solve2_2(numeval, (/2,3/), mu2, coeffs, 6, coeffs2)
   else
      coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
      call solve2_1(numeval, (/0/), mu2, coeffs, 1)
      call solve2_1(numeval, (/1/), mu2, coeffs, 2)
      call solve2_1(numeval, (/2/), mu2, coeffs, 3)
      call solve2_1(numeval, (/3/), mu2, coeffs, 4)
      call solve2_2(numeval, (/0,1/), mu2, coeffs, 1)
      call solve2_2(numeval, (/0,2/), mu2, coeffs, 2)
      call solve2_2(numeval, (/0,3/), mu2, coeffs, 3)
      call solve2_2(numeval, (/1,2/), mu2, coeffs, 4)
      call solve2_2(numeval, (/1,3/), mu2, coeffs, 5)
      call solve2_2(numeval, (/2,3/), mu2, coeffs, 6)
   end if
end subroutine solve2
!****f* src/interface/tens_rec/tenseval2
! NAME
!
! Function tenseval2
!
! USAGE
!
!  result = tenseval2(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_2
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval2(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_2), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval2
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 2
   end if
   tenseval2 = coeffs%c0
   if (1 .le. maxk) then
      tenseval2 = tenseval2 + tenseval2_1(Q, (/0/), coeffs%c1(1,:))
      tenseval2 = tenseval2 + tenseval2_1(Q, (/1/), coeffs%c1(2,:))
      tenseval2 = tenseval2 + tenseval2_1(Q, (/2/), coeffs%c1(3,:))
      tenseval2 = tenseval2 + tenseval2_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval2 = tenseval2 + tenseval2_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval2 = tenseval2 + tenseval2_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval2 = tenseval2 + tenseval2_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval2 = tenseval2 + tenseval2_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval2 = tenseval2 + tenseval2_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval2 = tenseval2 + tenseval2_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
end  function tenseval2
!****f* src/interface/tens_rec/ctenseval2
! NAME
!
! Function ctenseval2
!
! USAGE
!
!  result = ctenseval2(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_2
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval2(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_2), intent(in) :: coeffs
   complex(ki) :: ctenseval2
   ctenseval2 = coeffs%c0
   ctenseval2 = ctenseval2 + ctenseval2_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval2 = ctenseval2 + ctenseval2_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval2 = ctenseval2 + ctenseval2_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval2 = ctenseval2 + ctenseval2_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval2 = ctenseval2 + ctenseval2_2(Q, (/2,3/), coeffs%c2(6,:))
end  function ctenseval2
!****f* src/interface/tens_rec/print_coeffs_2
! NAME
!
! Subroutine print_coeffs_2
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 2
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_2
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_2(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_2), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
end subroutine print_coeffs_2
!****f* src/interface/tens_rec/reconstruct2
! NAME
!
! Subroutine reconstruct2
!
! USAGE
!
!  call reconstruct2(numeval, cm0, cm1, cm2)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 2,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_2, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type complex(ki), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type complex(ki), representing the
!               tensor in front of mu2^2 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1 and cm2 (if present). If cm1 and cm2 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2.
!
! EXAMPLE
!
!
!*****
subroutine     reconstruct2(numeval, cm0, cm1, cm2)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_2), intent(out) :: cm0
   complex(ki), intent(out), optional :: cm1
   complex(ki), intent(out), optional :: cm2
   complex(ki) :: ca, cb
   call solve2(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         ca = numeval(null_vec, +1.0_ki) - cm0%c0
         cb = numeval(null_vec, -1.0_ki) - cm0%c0
         cm1= 0.5_ki * (ca - cb)
         cm2= 0.5_ki * (ca + cb)
      else
         cm1 = numeval(null_vec, +1.0_ki) - cm0%c0
      end if
   end if
end subroutine reconstruct2
!****f* src/interface/tens_rec/solve3_1
! NAME
!
!  Subroutine solve3_1
!
! USAGE
!
!  call solve3_1(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q3_1.
!  The matrix mat3_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_3 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve3_1(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_3), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_5), intent(in), optional :: coeffs2
   complex(ki), dimension(3) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,3
         Q(indices(1)) = q3_1(i,1)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval3(Q, coeffs, 0) &
            & - tenseval5(Q, coeffs2, 1)
      end do
   else
      do i=1,3
         Q(indices(1)) = q3_1(i,1)
         xnum(i) = numeval(Q, mu2) - tenseval3(Q, coeffs, 0)
      end do
   end if
   coeffs%c1(idx,:) = matmul(mat3_1,xnum)
end subroutine solve3_1
!****f* src/interface/tens_rec/tenseval3_1
! NAME
!
! Function tenseval3_1
!
! USAGE
!
!  result = tenseval3_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(3) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval3_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(3), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval3_1
   real(ki) :: q0
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(2) + coeffs(3)*q0
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   tenseval3_1 = acc
end  function tenseval3_1
!****f* src/interface/tens_rec/ctenseval3_1
! NAME
!
! Function ctenseval3_1
!
! USAGE
!
!  result = ctenseval3_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(3) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval3_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(3), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval3_1
   complex(ki) :: q0
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(2) + coeffs(3)*q0
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   ctenseval3_1 = acc
end  function ctenseval3_1
!****f* src/interface/tens_rec/solve3_2
! NAME
!
!  Subroutine solve3_2
!
! USAGE
!
!  call solve3_2(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q3_2.
!  The matrix mat3_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_3 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve3_2(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_3), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_5), intent(in), optional :: coeffs2
   complex(ki), dimension(3) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,3
         Q(indices(1)) = q3_2(i,1)
         Q(indices(2)) = q3_2(i,2)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval3(Q, coeffs, 1) &
            & - tenseval5(Q, coeffs2, 2)
      end do
   else
      do i=1,3
         Q(indices(1)) = q3_2(i,1)
         Q(indices(2)) = q3_2(i,2)
         xnum(i) = numeval(Q, mu2) - tenseval3(Q, coeffs, 1)
      end do
   end if
   coeffs%c2(idx,:) = matmul(mat3_2,xnum)
end subroutine solve3_2
!****f* src/interface/tens_rec/tenseval3_2
! NAME
!
! Function tenseval3_2
!
! USAGE
!
!  result = tenseval3_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(3) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval3_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(3), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval3_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(2)*q1 + coeffs(3)*q0 + coeffs(1)
   acc = acc*q0*q1
   tenseval3_2 = acc
end  function tenseval3_2
!****f* src/interface/tens_rec/ctenseval3_2
! NAME
!
! Function ctenseval3_2
!
! USAGE
!
!  result = ctenseval3_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(3) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval3_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(3), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval3_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(2)*q1 + coeffs(3)*q0 + coeffs(1)
   acc = acc*q0*q1
   ctenseval3_2 = acc
end  function ctenseval3_2
!****f* src/interface/tens_rec/solve3_3
! NAME
!
!  Subroutine solve3_3
!
! USAGE
!
!  call solve3_3(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q3_3.
!  The matrix mat3_3 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_3 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve3_3(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(3), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_3), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_5), intent(in), optional :: coeffs2
   complex(ki), dimension(1) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,1
         Q(indices(1)) = q3_3(i,1)
         Q(indices(2)) = q3_3(i,2)
         Q(indices(3)) = q3_3(i,3)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval3(Q, coeffs, 2) &
            & - tenseval5(Q, coeffs2, 3)
      end do
   else
      do i=1,1
         Q(indices(1)) = q3_3(i,1)
         Q(indices(2)) = q3_3(i,2)
         Q(indices(3)) = q3_3(i,3)
         xnum(i) = numeval(Q, mu2) - tenseval3(Q, coeffs, 2)
      end do
   end if
   coeffs%c3(idx,:) = matmul(mat3_3,xnum)
end subroutine solve3_3
!****f* src/interface/tens_rec/tenseval3_3
! NAME
!
! Function tenseval3_3
!
! USAGE
!
!  result = tenseval3_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval3_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval3_3
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(1)*q0*q1*q2
   tenseval3_3 = acc
end  function tenseval3_3
!****f* src/interface/tens_rec/ctenseval3_3
! NAME
!
! Function ctenseval3_3
!
! USAGE
!
!  result = ctenseval3_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval3_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval3_3
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(1)*q0*q1*q2
   ctenseval3_3 = acc
end  function ctenseval3_3
!****f* src/interface/tens_rec/solve3
! NAME
!
! Subroutine solve3
!
! USAGE
!
!  call solve3(numeval, mu2, coeffs, coeffs2)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 3
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_3 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve3(numeval, mu2, coeffs, coeffs2)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_3), intent(inout) :: coeffs
   type(coeff_type_5), intent(in), optional :: coeffs2
   if (present(coeffs2)) then
      coeffs%c0 = numeval(null_vec, mu2) - coeffs2%c0
      call solve3_1(numeval, (/0/), mu2, coeffs, 1, coeffs2)
      call solve3_1(numeval, (/1/), mu2, coeffs, 2, coeffs2)
      call solve3_1(numeval, (/2/), mu2, coeffs, 3, coeffs2)
      call solve3_1(numeval, (/3/), mu2, coeffs, 4, coeffs2)
      call solve3_2(numeval, (/0,1/), mu2, coeffs, 1, coeffs2)
      call solve3_2(numeval, (/0,2/), mu2, coeffs, 2, coeffs2)
      call solve3_2(numeval, (/0,3/), mu2, coeffs, 3, coeffs2)
      call solve3_2(numeval, (/1,2/), mu2, coeffs, 4, coeffs2)
      call solve3_2(numeval, (/1,3/), mu2, coeffs, 5, coeffs2)
      call solve3_2(numeval, (/2,3/), mu2, coeffs, 6, coeffs2)
      call solve3_3(numeval, (/0,1,2/), mu2, coeffs, 1, coeffs2)
      call solve3_3(numeval, (/0,1,3/), mu2, coeffs, 2, coeffs2)
      call solve3_3(numeval, (/0,2,3/), mu2, coeffs, 3, coeffs2)
      call solve3_3(numeval, (/1,2,3/), mu2, coeffs, 4, coeffs2)
   else
      coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
      call solve3_1(numeval, (/0/), mu2, coeffs, 1)
      call solve3_1(numeval, (/1/), mu2, coeffs, 2)
      call solve3_1(numeval, (/2/), mu2, coeffs, 3)
      call solve3_1(numeval, (/3/), mu2, coeffs, 4)
      call solve3_2(numeval, (/0,1/), mu2, coeffs, 1)
      call solve3_2(numeval, (/0,2/), mu2, coeffs, 2)
      call solve3_2(numeval, (/0,3/), mu2, coeffs, 3)
      call solve3_2(numeval, (/1,2/), mu2, coeffs, 4)
      call solve3_2(numeval, (/1,3/), mu2, coeffs, 5)
      call solve3_2(numeval, (/2,3/), mu2, coeffs, 6)
      call solve3_3(numeval, (/0,1,2/), mu2, coeffs, 1)
      call solve3_3(numeval, (/0,1,3/), mu2, coeffs, 2)
      call solve3_3(numeval, (/0,2,3/), mu2, coeffs, 3)
      call solve3_3(numeval, (/1,2,3/), mu2, coeffs, 4)
   end if
end subroutine solve3
!****f* src/interface/tens_rec/tenseval3
! NAME
!
! Function tenseval3
!
! USAGE
!
!  result = tenseval3(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_3
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval3(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_3), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval3
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 3
   end if
   tenseval3 = coeffs%c0
   if (1 .le. maxk) then
      tenseval3 = tenseval3 + tenseval3_1(Q, (/0/), coeffs%c1(1,:))
      tenseval3 = tenseval3 + tenseval3_1(Q, (/1/), coeffs%c1(2,:))
      tenseval3 = tenseval3 + tenseval3_1(Q, (/2/), coeffs%c1(3,:))
      tenseval3 = tenseval3 + tenseval3_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval3 = tenseval3 + tenseval3_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval3 = tenseval3 + tenseval3_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval3 = tenseval3 + tenseval3_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval3 = tenseval3 + tenseval3_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval3 = tenseval3 + tenseval3_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval3 = tenseval3 + tenseval3_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
   if (3 .le. maxk) then
      tenseval3 = tenseval3 + tenseval3_3(Q, (/0,1,2/), coeffs%c3(1,:))
      tenseval3 = tenseval3 + tenseval3_3(Q, (/0,1,3/), coeffs%c3(2,:))
      tenseval3 = tenseval3 + tenseval3_3(Q, (/0,2,3/), coeffs%c3(3,:))
      tenseval3 = tenseval3 + tenseval3_3(Q, (/1,2,3/), coeffs%c3(4,:))
   end if
end  function tenseval3
!****f* src/interface/tens_rec/ctenseval3
! NAME
!
! Function ctenseval3
!
! USAGE
!
!  result = ctenseval3(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_3
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval3(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_3), intent(in) :: coeffs
   complex(ki) :: ctenseval3
   ctenseval3 = coeffs%c0
   ctenseval3 = ctenseval3 + ctenseval3_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval3 = ctenseval3 + ctenseval3_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval3 = ctenseval3 + ctenseval3_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval3 = ctenseval3 + ctenseval3_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval3 = ctenseval3 + ctenseval3_2(Q, (/2,3/), coeffs%c2(6,:))
   ctenseval3 = ctenseval3 + ctenseval3_3(Q, (/0,1,2/), coeffs%c3(1,:))
   ctenseval3 = ctenseval3 + ctenseval3_3(Q, (/0,1,3/), coeffs%c3(2,:))
   ctenseval3 = ctenseval3 + ctenseval3_3(Q, (/0,2,3/), coeffs%c3(3,:))
   ctenseval3 = ctenseval3 + ctenseval3_3(Q, (/1,2,3/), coeffs%c3(4,:))
end  function ctenseval3
!****f* src/interface/tens_rec/print_coeffs_3
! NAME
!
! Subroutine print_coeffs_3
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 3
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_3
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_3(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_3), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,3), ')*q(0)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,3), ')*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,3), ')*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,3), ')*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,2), ')*q(0)*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,3), ')*q(0)^2*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,2), ')*q(0)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,3), ')*q(0)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,2), ')*q(0)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,3), ')*q(0)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,2), ')*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,3), ')*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,2), ')*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,3), ')*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,2), ')*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,3), ')*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(1,1), ')*q(0)*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(2,1), ')*q(0)*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(3,1), ')*q(0)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(4,1), ')*q(1)*q(2)*q(3)'
end subroutine print_coeffs_3
!****f* src/interface/tens_rec/reconstruct3
! NAME
!
! Subroutine reconstruct3
!
! USAGE
!
!  call reconstruct3(numeval, cm0, cm1, cm2)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 3,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_3, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type type(coeff_type_1), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type type(coeff_type_1), representing the
!               tensor in front of mu2^2 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1 and cm2 (if present). If cm1 and cm2 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2.
!
! EXAMPLE
!
!
!*****
subroutine     reconstruct3(numeval, cm0, cm1, cm2)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_3), intent(out) :: cm0
   type(coeff_type_1), intent(out), optional :: cm1
   type(coeff_type_1), intent(out), optional :: cm2
   type(coeff_type_1) :: ca, cb
   call solve3(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         call solve1(numeval, +1.0_ki, ca, cm0)
         call solve1(numeval, -1.0_ki, cb, cm0)
         cm1%c0= 0.5_ki * (ca%c0 - cb%c0)
         cm2%c0= 0.5_ki * (ca%c0 + cb%c0)
         cm1%c1 = 0.5_ki * (ca%c1 - cb%c1)
         cm2%c1 = 0.5_ki * (ca%c1 + cb%c1)
      else
         call solve1(numeval, +1.0_ki, cm1, cm0)
      end if
   end if
end subroutine reconstruct3
!****f* src/interface/tens_rec/solve4_1
! NAME
!
!  Subroutine solve4_1
!
! USAGE
!
!  call solve4_1(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q4_1.
!  The matrix mat4_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_4 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve4_1(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_4), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_6), intent(in), optional :: coeffs2
   complex(ki), dimension(4) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,4
         Q(indices(1)) = q4_1(i,1)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval4(Q, coeffs, 0) &
            & - tenseval6(Q, coeffs2, 1)
      end do
   else
      do i=1,4
         Q(indices(1)) = q4_1(i,1)
         xnum(i) = numeval(Q, mu2) - tenseval4(Q, coeffs, 0)
      end do
   end if
   coeffs%c1(idx,:) = matmul(mat4_1,xnum)
end subroutine solve4_1
!****f* src/interface/tens_rec/tenseval4_1
! NAME
!
! Function tenseval4_1
!
! USAGE
!
!  result = tenseval4_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(4) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval4_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(4), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval4_1
   real(ki) :: q0
   complex(ki) :: reg2
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(3) + coeffs(4)*q0
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   tenseval4_1 = acc
end  function tenseval4_1
!****f* src/interface/tens_rec/ctenseval4_1
! NAME
!
! Function ctenseval4_1
!
! USAGE
!
!  result = ctenseval4_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(4) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval4_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(4), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval4_1
   complex(ki) :: q0
   complex(ki) :: reg2
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(3) + coeffs(4)*q0
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   ctenseval4_1 = acc
end  function ctenseval4_1
!****f* src/interface/tens_rec/solve4_2
! NAME
!
!  Subroutine solve4_2
!
! USAGE
!
!  call solve4_2(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q4_2.
!  The matrix mat4_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_4 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve4_2(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_4), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_6), intent(in), optional :: coeffs2
   complex(ki), dimension(6) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,6
         Q(indices(1)) = q4_2(i,1)
         Q(indices(2)) = q4_2(i,2)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval4(Q, coeffs, 1) &
            & - tenseval6(Q, coeffs2, 2)
      end do
   else
      do i=1,6
         Q(indices(1)) = q4_2(i,1)
         Q(indices(2)) = q4_2(i,2)
         xnum(i) = numeval(Q, mu2) - tenseval4(Q, coeffs, 1)
      end do
   end if
   coeffs%c2(idx,:) = matmul(mat4_2,xnum)
end subroutine solve4_2
!****f* src/interface/tens_rec/tenseval4_2
! NAME
!
! Function tenseval4_2
!
! USAGE
!
!  result = tenseval4_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(6) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval4_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(6), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval4_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: reg2
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(3)*q1 + coeffs(5)*q0 + coeffs(2)
   reg1 = acc*q1
   acc = coeffs(6)*q0 + coeffs(4)
   reg2 = acc*q0
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   tenseval4_2 = acc
end  function tenseval4_2
!****f* src/interface/tens_rec/ctenseval4_2
! NAME
!
! Function ctenseval4_2
!
! USAGE
!
!  result = ctenseval4_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(6) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval4_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(6), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval4_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: reg2
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(3)*q1 + coeffs(5)*q0 + coeffs(2)
   reg1 = acc*q1
   acc = coeffs(6)*q0 + coeffs(4)
   reg2 = acc*q0
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   ctenseval4_2 = acc
end  function ctenseval4_2
!****f* src/interface/tens_rec/solve4_3
! NAME
!
!  Subroutine solve4_3
!
! USAGE
!
!  call solve4_3(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q4_3.
!  The matrix mat4_3 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_4 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve4_3(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(3), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_4), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_6), intent(in), optional :: coeffs2
   complex(ki), dimension(4) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,4
         Q(indices(1)) = q4_3(i,1)
         Q(indices(2)) = q4_3(i,2)
         Q(indices(3)) = q4_3(i,3)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval4(Q, coeffs, 2) &
            & - tenseval6(Q, coeffs2, 3)
      end do
   else
      do i=1,4
         Q(indices(1)) = q4_3(i,1)
         Q(indices(2)) = q4_3(i,2)
         Q(indices(3)) = q4_3(i,3)
         xnum(i) = numeval(Q, mu2) - tenseval4(Q, coeffs, 2)
      end do
   end if
   coeffs%c3(idx,:) = matmul(mat4_3,xnum)
end subroutine solve4_3
!****f* src/interface/tens_rec/tenseval4_3
! NAME
!
! Function tenseval4_3
!
! USAGE
!
!  result = tenseval4_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(4) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval4_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(4), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval4_3
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(4)*q0 + coeffs(3)*q1 + coeffs(1) + coeffs(2)*q2
   acc = acc*q0*q1*q2
   tenseval4_3 = acc
end  function tenseval4_3
!****f* src/interface/tens_rec/ctenseval4_3
! NAME
!
! Function ctenseval4_3
!
! USAGE
!
!  result = ctenseval4_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(4) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval4_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(4), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval4_3
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(4)*q0 + coeffs(3)*q1 + coeffs(1) + coeffs(2)*q2
   acc = acc*q0*q1*q2
   ctenseval4_3 = acc
end  function ctenseval4_3
!****f* src/interface/tens_rec/solve4_4
! NAME
!
!  Subroutine solve4_4
!
! USAGE
!
!  call solve4_4(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q4_4.
!  The matrix mat4_4 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_4 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve4_4(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(4), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_4), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_6), intent(in), optional :: coeffs2
   complex(ki), dimension(1) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   if (present(coeffs2)) then
      do i=1,1
         Q(indices(1)) = q4_4(i,1)
         Q(indices(2)) = q4_4(i,2)
         Q(indices(3)) = q4_4(i,3)
         Q(indices(4)) = q4_4(i,4)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval4(Q, coeffs, 3) &
            & - tenseval6(Q, coeffs2, 4)
      end do
   else
      do i=1,1
         Q(indices(1)) = q4_4(i,1)
         Q(indices(2)) = q4_4(i,2)
         Q(indices(3)) = q4_4(i,3)
         Q(indices(4)) = q4_4(i,4)
         xnum(i) = numeval(Q, mu2) - tenseval4(Q, coeffs, 3)
      end do
   end if
   coeffs%c4(idx,:) = matmul(mat4_4,xnum)
end subroutine solve4_4
!****f* src/interface/tens_rec/tenseval4_4
! NAME
!
! Function tenseval4_4
!
! USAGE
!
!  result = tenseval4_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval4_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval4_4
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   real(ki) :: q3
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(1)*q0*q1*q2*q3
   tenseval4_4 = acc
end  function tenseval4_4
!****f* src/interface/tens_rec/ctenseval4_4
! NAME
!
! Function ctenseval4_4
!
! USAGE
!
!  result = ctenseval4_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(1) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval4_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(1), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval4_4
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: q3
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(1)*q0*q1*q2*q3
   ctenseval4_4 = acc
end  function ctenseval4_4
!****f* src/interface/tens_rec/solve4
! NAME
!
! Subroutine solve4
!
! USAGE
!
!  call solve4(numeval, mu2, coeffs, coeffs2)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 4
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_4 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve4(numeval, mu2, coeffs, coeffs2)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_4), intent(inout) :: coeffs
   type(coeff_type_6), intent(in), optional :: coeffs2
   if (present(coeffs2)) then
      coeffs%c0 = numeval(null_vec, mu2) - coeffs2%c0
      call solve4_1(numeval, (/0/), mu2, coeffs, 1, coeffs2)
      call solve4_1(numeval, (/1/), mu2, coeffs, 2, coeffs2)
      call solve4_1(numeval, (/2/), mu2, coeffs, 3, coeffs2)
      call solve4_1(numeval, (/3/), mu2, coeffs, 4, coeffs2)
      call solve4_2(numeval, (/0,1/), mu2, coeffs, 1, coeffs2)
      call solve4_2(numeval, (/0,2/), mu2, coeffs, 2, coeffs2)
      call solve4_2(numeval, (/0,3/), mu2, coeffs, 3, coeffs2)
      call solve4_2(numeval, (/1,2/), mu2, coeffs, 4, coeffs2)
      call solve4_2(numeval, (/1,3/), mu2, coeffs, 5, coeffs2)
      call solve4_2(numeval, (/2,3/), mu2, coeffs, 6, coeffs2)
      call solve4_3(numeval, (/0,1,2/), mu2, coeffs, 1, coeffs2)
      call solve4_3(numeval, (/0,1,3/), mu2, coeffs, 2, coeffs2)
      call solve4_3(numeval, (/0,2,3/), mu2, coeffs, 3, coeffs2)
      call solve4_3(numeval, (/1,2,3/), mu2, coeffs, 4, coeffs2)
      call solve4_4(numeval, (/0,1,2,3/), mu2, coeffs, 1, coeffs2)
   else
      coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
      call solve4_1(numeval, (/0/), mu2, coeffs, 1)
      call solve4_1(numeval, (/1/), mu2, coeffs, 2)
      call solve4_1(numeval, (/2/), mu2, coeffs, 3)
      call solve4_1(numeval, (/3/), mu2, coeffs, 4)
      call solve4_2(numeval, (/0,1/), mu2, coeffs, 1)
      call solve4_2(numeval, (/0,2/), mu2, coeffs, 2)
      call solve4_2(numeval, (/0,3/), mu2, coeffs, 3)
      call solve4_2(numeval, (/1,2/), mu2, coeffs, 4)
      call solve4_2(numeval, (/1,3/), mu2, coeffs, 5)
      call solve4_2(numeval, (/2,3/), mu2, coeffs, 6)
      call solve4_3(numeval, (/0,1,2/), mu2, coeffs, 1)
      call solve4_3(numeval, (/0,1,3/), mu2, coeffs, 2)
      call solve4_3(numeval, (/0,2,3/), mu2, coeffs, 3)
      call solve4_3(numeval, (/1,2,3/), mu2, coeffs, 4)
      call solve4_4(numeval, (/0,1,2,3/), mu2, coeffs, 1)
   end if
end subroutine solve4
!****f* src/interface/tens_rec/tenseval4
! NAME
!
! Function tenseval4
!
! USAGE
!
!  result = tenseval4(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_4
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval4(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_4), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval4
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 4
   end if
   tenseval4 = coeffs%c0
   if (1 .le. maxk) then
      tenseval4 = tenseval4 + tenseval4_1(Q, (/0/), coeffs%c1(1,:))
      tenseval4 = tenseval4 + tenseval4_1(Q, (/1/), coeffs%c1(2,:))
      tenseval4 = tenseval4 + tenseval4_1(Q, (/2/), coeffs%c1(3,:))
      tenseval4 = tenseval4 + tenseval4_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval4 = tenseval4 + tenseval4_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval4 = tenseval4 + tenseval4_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval4 = tenseval4 + tenseval4_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval4 = tenseval4 + tenseval4_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval4 = tenseval4 + tenseval4_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval4 = tenseval4 + tenseval4_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
   if (3 .le. maxk) then
      tenseval4 = tenseval4 + tenseval4_3(Q, (/0,1,2/), coeffs%c3(1,:))
      tenseval4 = tenseval4 + tenseval4_3(Q, (/0,1,3/), coeffs%c3(2,:))
      tenseval4 = tenseval4 + tenseval4_3(Q, (/0,2,3/), coeffs%c3(3,:))
      tenseval4 = tenseval4 + tenseval4_3(Q, (/1,2,3/), coeffs%c3(4,:))
   end if
   if (4 .le. maxk) then
      tenseval4 = tenseval4 + tenseval4_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
   end if
end  function tenseval4
!****f* src/interface/tens_rec/ctenseval4
! NAME
!
! Function ctenseval4
!
! USAGE
!
!  result = ctenseval4(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_4
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval4(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_4), intent(in) :: coeffs
   complex(ki) :: ctenseval4
   ctenseval4 = coeffs%c0
   ctenseval4 = ctenseval4 + ctenseval4_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval4 = ctenseval4 + ctenseval4_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval4 = ctenseval4 + ctenseval4_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval4 = ctenseval4 + ctenseval4_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval4 = ctenseval4 + ctenseval4_2(Q, (/2,3/), coeffs%c2(6,:))
   ctenseval4 = ctenseval4 + ctenseval4_3(Q, (/0,1,2/), coeffs%c3(1,:))
   ctenseval4 = ctenseval4 + ctenseval4_3(Q, (/0,1,3/), coeffs%c3(2,:))
   ctenseval4 = ctenseval4 + ctenseval4_3(Q, (/0,2,3/), coeffs%c3(3,:))
   ctenseval4 = ctenseval4 + ctenseval4_3(Q, (/1,2,3/), coeffs%c3(4,:))
   ctenseval4 = ctenseval4 + ctenseval4_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
end  function ctenseval4
!****f* src/interface/tens_rec/print_coeffs_4
! NAME
!
! Subroutine print_coeffs_4
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 4
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_4
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_4(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_4), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,3), ')*q(0)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,4), ')*q(0)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,3), ')*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,4), ')*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,3), ')*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,4), ')*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,3), ')*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,4), ')*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,2), ')*q(0)*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,3), ')*q(0)*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,4), ')*q(0)^2*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,5), ')*q(0)^2*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,6), ')*q(0)^3*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,2), ')*q(0)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,3), ')*q(0)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,4), ')*q(0)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,5), ')*q(0)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,6), ')*q(0)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,2), ')*q(0)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,3), ')*q(0)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,4), ')*q(0)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,5), ')*q(0)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,6), ')*q(0)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,2), ')*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,3), ')*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,4), ')*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,5), ')*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,6), ')*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,2), ')*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,3), ')*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,4), ')*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,5), ')*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,6), ')*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,2), ')*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,3), ')*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,4), ')*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,5), ')*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,6), ')*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(1,1), ')*q(0)*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,2), ')*q(0)*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,3), ')*q(0)*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,4), ')*q(0)^2*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(2,1), ')*q(0)*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,2), ')*q(0)*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,3), ')*q(0)*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,4), ')*q(0)^2*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(3,1), ')*q(0)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,2), ')*q(0)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,3), ')*q(0)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,4), ')*q(0)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(4,1), ')*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,2), ')*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,3), ')*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,4), ')*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A21)') ' + (',  coeffs%c4(1,1), ')*q(0)*q(1)*q(2)*q(3)'
end subroutine print_coeffs_4
!****f* src/interface/tens_rec/reconstruct4
! NAME
!
! Subroutine reconstruct4
!
! USAGE
!
!  call reconstruct4(numeval, cm0, cm1, cm2)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 4,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_4, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type type(coeff_type_2), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type type(coeff_type_2), representing the
!               tensor in front of mu2^2 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1 and cm2 (if present). If cm1 and cm2 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2.
!
! EXAMPLE
!
!
!*****
subroutine     reconstruct4(numeval, cm0, cm1, cm2)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_4), intent(out) :: cm0
   type(coeff_type_2), intent(out), optional :: cm1
   type(coeff_type_2), intent(out), optional :: cm2
   type(coeff_type_2) :: ca, cb
   call solve4(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         call solve2(numeval, +1.0_ki, ca, cm0)
         call solve2(numeval, -1.0_ki, cb, cm0)
         cm1%c0= 0.5_ki * (ca%c0 - cb%c0)
         cm2%c0= 0.5_ki * (ca%c0 + cb%c0)
         cm1%c1 = 0.5_ki * (ca%c1 - cb%c1)
         cm2%c1 = 0.5_ki * (ca%c1 + cb%c1)
         cm1%c2 = 0.5_ki * (ca%c2 - cb%c2)
         cm2%c2 = 0.5_ki * (ca%c2 + cb%c2)
      else
         call solve2(numeval, +1.0_ki, cm1, cm0)
      end if
   end if
end subroutine reconstruct4
!****f* src/interface/tens_rec/solve5_1
! NAME
!
!  Subroutine solve5_1
!
! USAGE
!
!  call solve5_1(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q5_1.
!  The matrix mat5_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_5 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve5_1(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_5), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_7), intent(in), optional :: coeffs2
   complex(ki), dimension(5) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,5
         Q(indices(1)) = q5_1(i,1)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval5(Q, coeffs, 0) &
            & - tenseval7(Q, coeffs2, 1)
      end do
   else
      do i=1,5
         Q(indices(1)) = q5_1(i,1)
         xnum(i) = numeval(Q, mu2) - tenseval5(Q, coeffs, 0)
      end do
   end if
   coeffs%c1(idx,:) = matmul(mat5_1,xnum)
end subroutine solve5_1
!****f* src/interface/tens_rec/tenseval5_1
! NAME
!
! Function tenseval5_1
!
! USAGE
!
!  result = tenseval5_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(5) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval5_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(5), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval5_1
   real(ki) :: q0
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(4) + coeffs(5)*q0
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   tenseval5_1 = acc
end  function tenseval5_1
!****f* src/interface/tens_rec/ctenseval5_1
! NAME
!
! Function ctenseval5_1
!
! USAGE
!
!  result = ctenseval5_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(5) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval5_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(5), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval5_1
   complex(ki) :: q0
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(4) + coeffs(5)*q0
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   ctenseval5_1 = acc
end  function ctenseval5_1
!****f* src/interface/tens_rec/solve5_2
! NAME
!
!  Subroutine solve5_2
!
! USAGE
!
!  call solve5_2(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q5_2.
!  The matrix mat5_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_5 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve5_2(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_5), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_7), intent(in), optional :: coeffs2
   complex(ki), dimension(10) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,10
         Q(indices(1)) = q5_2(i,1)
         Q(indices(2)) = q5_2(i,2)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval5(Q, coeffs, 1) &
            & - tenseval7(Q, coeffs2, 2)
      end do
   else
      do i=1,10
         Q(indices(1)) = q5_2(i,1)
         Q(indices(2)) = q5_2(i,2)
         xnum(i) = numeval(Q, mu2) - tenseval5(Q, coeffs, 1)
      end do
   end if
   coeffs%c2(idx,:) = matmul(mat5_2,xnum)
end subroutine solve5_2
!****f* src/interface/tens_rec/tenseval5_2
! NAME
!
! Function tenseval5_2
!
! USAGE
!
!  result = tenseval5_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(10) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval5_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(10), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval5_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(7)*q1 + coeffs(9)*q0 + coeffs(6)
   reg2 = acc*q0
   acc = coeffs(4)*q1 + coeffs(3)
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(10)*q0 + coeffs(8)
   reg3 = acc*q0
   acc = coeffs(5)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   tenseval5_2 = acc
end  function tenseval5_2
!****f* src/interface/tens_rec/ctenseval5_2
! NAME
!
! Function ctenseval5_2
!
! USAGE
!
!  result = ctenseval5_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(10) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval5_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(10), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval5_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(7)*q1 + coeffs(9)*q0 + coeffs(6)
   reg2 = acc*q0
   acc = coeffs(4)*q1 + coeffs(3)
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(10)*q0 + coeffs(8)
   reg3 = acc*q0
   acc = coeffs(5)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   ctenseval5_2 = acc
end  function ctenseval5_2
!****f* src/interface/tens_rec/solve5_3
! NAME
!
!  Subroutine solve5_3
!
! USAGE
!
!  call solve5_3(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q5_3.
!  The matrix mat5_3 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_5 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve5_3(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(3), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_5), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_7), intent(in), optional :: coeffs2
   complex(ki), dimension(10) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   if (present(coeffs2)) then
      do i=1,10
         Q(indices(1)) = q5_3(i,1)
         Q(indices(2)) = q5_3(i,2)
         Q(indices(3)) = q5_3(i,3)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval5(Q, coeffs, 2) &
            & - tenseval7(Q, coeffs2, 3)
      end do
   else
      do i=1,10
         Q(indices(1)) = q5_3(i,1)
         Q(indices(2)) = q5_3(i,2)
         Q(indices(3)) = q5_3(i,3)
         xnum(i) = numeval(Q, mu2) - tenseval5(Q, coeffs, 2)
      end do
   end if
   coeffs%c3(idx,:) = matmul(mat5_3,xnum)
end subroutine solve5_3
!****f* src/interface/tens_rec/tenseval5_3
! NAME
!
! Function tenseval5_3
!
! USAGE
!
!  result = tenseval5_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(10) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval5_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(10), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval5_3
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(10)*q0 + coeffs(9)*q1 + coeffs(7) + coeffs(8)*q2
   reg1 = acc*q0
   acc = coeffs(6)*q1 + coeffs(4) + coeffs(5)*q2
   reg2 = acc*q1
   acc = coeffs(2) + coeffs(3)*q2
   reg3 = acc*q2
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   tenseval5_3 = acc
end  function tenseval5_3
!****f* src/interface/tens_rec/ctenseval5_3
! NAME
!
! Function ctenseval5_3
!
! USAGE
!
!  result = ctenseval5_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(10) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval5_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(10), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval5_3
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(10)*q0 + coeffs(9)*q1 + coeffs(7) + coeffs(8)*q2
   reg1 = acc*q0
   acc = coeffs(6)*q1 + coeffs(4) + coeffs(5)*q2
   reg2 = acc*q1
   acc = coeffs(2) + coeffs(3)*q2
   reg3 = acc*q2
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   ctenseval5_3 = acc
end  function ctenseval5_3
!****f* src/interface/tens_rec/solve5_4
! NAME
!
!  Subroutine solve5_4
!
! USAGE
!
!  call solve5_4(numeval, indices, mu2, coeffs, idx, coeffs2)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q5_4.
!  The matrix mat5_4 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_5 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve5_4(numeval, indices, mu2, coeffs, idx, coeffs2)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(4), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_5), intent(inout) :: coeffs
   integer, intent(in) :: idx
   type(coeff_type_7), intent(in), optional :: coeffs2
   complex(ki), dimension(5) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   if (present(coeffs2)) then
      do i=1,5
         Q(indices(1)) = q5_4(i,1)
         Q(indices(2)) = q5_4(i,2)
         Q(indices(3)) = q5_4(i,3)
         Q(indices(4)) = q5_4(i,4)
         xnum(i) = numeval(Q, mu2) &
            & - tenseval5(Q, coeffs, 3) &
            & - tenseval7(Q, coeffs2, 4)
      end do
   else
      do i=1,5
         Q(indices(1)) = q5_4(i,1)
         Q(indices(2)) = q5_4(i,2)
         Q(indices(3)) = q5_4(i,3)
         Q(indices(4)) = q5_4(i,4)
         xnum(i) = numeval(Q, mu2) - tenseval5(Q, coeffs, 3)
      end do
   end if
   coeffs%c4(idx,:) = matmul(mat5_4,xnum)
end subroutine solve5_4
!****f* src/interface/tens_rec/tenseval5_4
! NAME
!
! Function tenseval5_4
!
! USAGE
!
!  result = tenseval5_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(5) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval5_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(5), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval5_4
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   real(ki) :: q3
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(2)*q3 + coeffs(1) + coeffs(5)*q0 + coeffs(3)*q2 + coeffs(4)*q1
   acc = acc*q0*q1*q2*q3
   tenseval5_4 = acc
end  function tenseval5_4
!****f* src/interface/tens_rec/ctenseval5_4
! NAME
!
! Function ctenseval5_4
!
! USAGE
!
!  result = ctenseval5_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(5) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval5_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(5), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval5_4
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: q3
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(2)*q3 + coeffs(1) + coeffs(5)*q0 + coeffs(3)*q2 + coeffs(4)*q1
   acc = acc*q0*q1*q2*q3
   ctenseval5_4 = acc
end  function ctenseval5_4
!****f* src/interface/tens_rec/solve5
! NAME
!
! Subroutine solve5
!
! USAGE
!
!  call solve5(numeval, mu2, coeffs, coeffs2)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 5
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_5 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve5(numeval, mu2, coeffs, coeffs2)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_5), intent(inout) :: coeffs
   type(coeff_type_7), intent(in), optional :: coeffs2
   if (present(coeffs2)) then
      coeffs%c0 = numeval(null_vec, mu2) - coeffs2%c0
      call solve5_1(numeval, (/0/), mu2, coeffs, 1, coeffs2)
      call solve5_1(numeval, (/1/), mu2, coeffs, 2, coeffs2)
      call solve5_1(numeval, (/2/), mu2, coeffs, 3, coeffs2)
      call solve5_1(numeval, (/3/), mu2, coeffs, 4, coeffs2)
      call solve5_2(numeval, (/0,1/), mu2, coeffs, 1, coeffs2)
      call solve5_2(numeval, (/0,2/), mu2, coeffs, 2, coeffs2)
      call solve5_2(numeval, (/0,3/), mu2, coeffs, 3, coeffs2)
      call solve5_2(numeval, (/1,2/), mu2, coeffs, 4, coeffs2)
      call solve5_2(numeval, (/1,3/), mu2, coeffs, 5, coeffs2)
      call solve5_2(numeval, (/2,3/), mu2, coeffs, 6, coeffs2)
      call solve5_3(numeval, (/0,1,2/), mu2, coeffs, 1, coeffs2)
      call solve5_3(numeval, (/0,1,3/), mu2, coeffs, 2, coeffs2)
      call solve5_3(numeval, (/0,2,3/), mu2, coeffs, 3, coeffs2)
      call solve5_3(numeval, (/1,2,3/), mu2, coeffs, 4, coeffs2)
      call solve5_4(numeval, (/0,1,2,3/), mu2, coeffs, 1, coeffs2)
   else
      coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
      call solve5_1(numeval, (/0/), mu2, coeffs, 1)
      call solve5_1(numeval, (/1/), mu2, coeffs, 2)
      call solve5_1(numeval, (/2/), mu2, coeffs, 3)
      call solve5_1(numeval, (/3/), mu2, coeffs, 4)
      call solve5_2(numeval, (/0,1/), mu2, coeffs, 1)
      call solve5_2(numeval, (/0,2/), mu2, coeffs, 2)
      call solve5_2(numeval, (/0,3/), mu2, coeffs, 3)
      call solve5_2(numeval, (/1,2/), mu2, coeffs, 4)
      call solve5_2(numeval, (/1,3/), mu2, coeffs, 5)
      call solve5_2(numeval, (/2,3/), mu2, coeffs, 6)
      call solve5_3(numeval, (/0,1,2/), mu2, coeffs, 1)
      call solve5_3(numeval, (/0,1,3/), mu2, coeffs, 2)
      call solve5_3(numeval, (/0,2,3/), mu2, coeffs, 3)
      call solve5_3(numeval, (/1,2,3/), mu2, coeffs, 4)
      call solve5_4(numeval, (/0,1,2,3/), mu2, coeffs, 1)
   end if
end subroutine solve5
!****f* src/interface/tens_rec/tenseval5
! NAME
!
! Function tenseval5
!
! USAGE
!
!  result = tenseval5(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_5
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval5(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_5), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval5
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 4
   end if
   tenseval5 = coeffs%c0
   if (1 .le. maxk) then
      tenseval5 = tenseval5 + tenseval5_1(Q, (/0/), coeffs%c1(1,:))
      tenseval5 = tenseval5 + tenseval5_1(Q, (/1/), coeffs%c1(2,:))
      tenseval5 = tenseval5 + tenseval5_1(Q, (/2/), coeffs%c1(3,:))
      tenseval5 = tenseval5 + tenseval5_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval5 = tenseval5 + tenseval5_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval5 = tenseval5 + tenseval5_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval5 = tenseval5 + tenseval5_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval5 = tenseval5 + tenseval5_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval5 = tenseval5 + tenseval5_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval5 = tenseval5 + tenseval5_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
   if (3 .le. maxk) then
      tenseval5 = tenseval5 + tenseval5_3(Q, (/0,1,2/), coeffs%c3(1,:))
      tenseval5 = tenseval5 + tenseval5_3(Q, (/0,1,3/), coeffs%c3(2,:))
      tenseval5 = tenseval5 + tenseval5_3(Q, (/0,2,3/), coeffs%c3(3,:))
      tenseval5 = tenseval5 + tenseval5_3(Q, (/1,2,3/), coeffs%c3(4,:))
   end if
   if (4 .le. maxk) then
      tenseval5 = tenseval5 + tenseval5_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
   end if
end  function tenseval5
!****f* src/interface/tens_rec/ctenseval5
! NAME
!
! Function ctenseval5
!
! USAGE
!
!  result = ctenseval5(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_5
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval5(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_5), intent(in) :: coeffs
   complex(ki) :: ctenseval5
   ctenseval5 = coeffs%c0
   ctenseval5 = ctenseval5 + ctenseval5_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval5 = ctenseval5 + ctenseval5_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval5 = ctenseval5 + ctenseval5_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval5 = ctenseval5 + ctenseval5_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval5 = ctenseval5 + ctenseval5_2(Q, (/2,3/), coeffs%c2(6,:))
   ctenseval5 = ctenseval5 + ctenseval5_3(Q, (/0,1,2/), coeffs%c3(1,:))
   ctenseval5 = ctenseval5 + ctenseval5_3(Q, (/0,1,3/), coeffs%c3(2,:))
   ctenseval5 = ctenseval5 + ctenseval5_3(Q, (/0,2,3/), coeffs%c3(3,:))
   ctenseval5 = ctenseval5 + ctenseval5_3(Q, (/1,2,3/), coeffs%c3(4,:))
   ctenseval5 = ctenseval5 + ctenseval5_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
end  function ctenseval5
!****f* src/interface/tens_rec/print_coeffs_5
! NAME
!
! Subroutine print_coeffs_5
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 5
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_5
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_5(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_5), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,3), ')*q(0)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,4), ')*q(0)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,5), ')*q(0)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,3), ')*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,4), ')*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,5), ')*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,3), ')*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,4), ')*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,5), ')*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,3), ')*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,4), ')*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,5), ')*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,2), ')*q(0)*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,3), ')*q(0)*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,4), ')*q(0)*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,5), ')*q(0)^2*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,6), ')*q(0)^2*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,7), ')*q(0)^2*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,8), ')*q(0)^3*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,9), ')*q(0)^3*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,10), ')*q(0)^4*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,2), ')*q(0)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,3), ')*q(0)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,4), ')*q(0)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,5), ')*q(0)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,6), ')*q(0)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,7), ')*q(0)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,8), ')*q(0)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,9), ')*q(0)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,10), ')*q(0)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,2), ')*q(0)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,3), ')*q(0)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,4), ')*q(0)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,5), ')*q(0)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,6), ')*q(0)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,7), ')*q(0)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,8), ')*q(0)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,9), ')*q(0)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,10), ')*q(0)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,2), ')*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,3), ')*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,4), ')*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,5), ')*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,6), ')*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,7), ')*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,8), ')*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,9), ')*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,10), ')*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,2), ')*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,3), ')*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,4), ')*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,5), ')*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,6), ')*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,7), ')*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,8), ')*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,9), ')*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,10), ')*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,2), ')*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,3), ')*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,4), ')*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,5), ')*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,6), ')*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,7), ')*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,8), ')*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,9), ')*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,10), ')*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(1,1), ')*q(0)*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,2), ')*q(0)*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,3), ')*q(0)*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,4), ')*q(0)*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,5), ')*q(0)*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,6), ')*q(0)*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,7), ')*q(0)^2*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,8), ')*q(0)^2*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,9), ')*q(0)^2*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,10), ')*q(0)^3*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(2,1), ')*q(0)*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,2), ')*q(0)*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,3), ')*q(0)*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,4), ')*q(0)*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,5), ')*q(0)*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,6), ')*q(0)*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,7), ')*q(0)^2*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,8), ')*q(0)^2*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,9), ')*q(0)^2*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,10), ')*q(0)^3*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(3,1), ')*q(0)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,2), ')*q(0)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,3), ')*q(0)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,4), ')*q(0)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,5), ')*q(0)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,6), ')*q(0)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,7), ')*q(0)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,8), ')*q(0)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,9), ')*q(0)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,10), ')*q(0)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(4,1), ')*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,2), ')*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,3), ')*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,4), ')*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,5), ')*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,6), ')*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,7), ')*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,8), ')*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,9), ')*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,10), ')*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A21)') ' + (',  coeffs%c4(1,1), ')*q(0)*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,2), ')*q(0)*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,3), ')*q(0)*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,4), ')*q(0)*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,5), ')*q(0)^2*q(1)*q(2)*q(3)'
end subroutine print_coeffs_5
!****f* src/interface/tens_rec/reconstruct5
! NAME
!
! Subroutine reconstruct5
!
! USAGE
!
!  call reconstruct5(numeval, cm0, cm1, cm2)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 5,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_5, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type type(coeff_type_3), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type type(coeff_type_3), representing the
!               tensor in front of mu2^2 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1 and cm2 (if present). If cm1 and cm2 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2.
!
! EXAMPLE
!
!
!*****
subroutine     reconstruct5(numeval, cm0, cm1, cm2)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_5), intent(out) :: cm0
   type(coeff_type_3), intent(out), optional :: cm1
   type(coeff_type_3), intent(out), optional :: cm2
   type(coeff_type_3) :: ca, cb
   call solve5(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         call solve3(numeval, +1.0_ki, ca, cm0)
         call solve3(numeval, -1.0_ki, cb, cm0)
         cm1%c0= 0.5_ki * (ca%c0 - cb%c0)
         cm2%c0= 0.5_ki * (ca%c0 + cb%c0)
         cm1%c1 = 0.5_ki * (ca%c1 - cb%c1)
         cm2%c1 = 0.5_ki * (ca%c1 + cb%c1)
         cm1%c2 = 0.5_ki * (ca%c2 - cb%c2)
         cm2%c2 = 0.5_ki * (ca%c2 + cb%c2)
         cm1%c3 = 0.5_ki * (ca%c3 - cb%c3)
         cm2%c3 = 0.5_ki * (ca%c3 + cb%c3)
      else
         call solve3(numeval, +1.0_ki, cm1, cm0)
      end if
   end if
end subroutine reconstruct5
!****f* src/interface/tens_rec/solve6_1
! NAME
!
!  Subroutine solve6_1
!
! USAGE
!
!  call solve6_1(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q6_1.
!  The matrix mat6_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_6 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve6_1(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_6), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(6) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,6
      Q(indices(1)) = q6_1(i,1)
      xnum(i) = numeval(Q, mu2) - tenseval6(Q, coeffs, 0)
   end do
   coeffs%c1(idx,:) = matmul(mat6_1,xnum)
end subroutine solve6_1
!****f* src/interface/tens_rec/tenseval6_1
! NAME
!
! Function tenseval6_1
!
! USAGE
!
!  result = tenseval6_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(6) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval6_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(6), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval6_1
   real(ki) :: q0
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(5) + coeffs(6)*q0
   reg4 = acc*q0
   acc = coeffs(4)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   tenseval6_1 = acc
end  function tenseval6_1
!****f* src/interface/tens_rec/ctenseval6_1
! NAME
!
! Function ctenseval6_1
!
! USAGE
!
!  result = ctenseval6_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(6) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval6_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(6), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval6_1
   complex(ki) :: q0
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(5) + coeffs(6)*q0
   reg4 = acc*q0
   acc = coeffs(4)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   ctenseval6_1 = acc
end  function ctenseval6_1
!****f* src/interface/tens_rec/solve6_2
! NAME
!
!  Subroutine solve6_2
!
! USAGE
!
!  call solve6_2(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q6_2.
!  The matrix mat6_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_6 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve6_2(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_6), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(15) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,15
      Q(indices(1)) = q6_2(i,1)
      Q(indices(2)) = q6_2(i,2)
      xnum(i) = numeval(Q, mu2) - tenseval6(Q, coeffs, 1)
   end do
   coeffs%c2(idx,:) = matmul(mat6_2,xnum)
end subroutine solve6_2
!****f* src/interface/tens_rec/tenseval6_2
! NAME
!
! Function tenseval6_2
!
! USAGE
!
!  result = tenseval6_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(15) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval6_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(15), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval6_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(12)*q1 + coeffs(14)*q0 + coeffs(11)
   reg3 = acc*q0
   acc = coeffs(9)*q1 + coeffs(8)
   reg4 = acc*q1
   acc = coeffs(7)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(15)*q0 + coeffs(13)
   reg4 = acc*q0
   acc = coeffs(10)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(6)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(5)*q1 + coeffs(4)
   reg4 = acc*q1
   acc = coeffs(3)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   tenseval6_2 = acc
end  function tenseval6_2
!****f* src/interface/tens_rec/ctenseval6_2
! NAME
!
! Function ctenseval6_2
!
! USAGE
!
!  result = ctenseval6_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(15) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval6_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(15), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval6_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(12)*q1 + coeffs(14)*q0 + coeffs(11)
   reg3 = acc*q0
   acc = coeffs(9)*q1 + coeffs(8)
   reg4 = acc*q1
   acc = coeffs(7)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(15)*q0 + coeffs(13)
   reg4 = acc*q0
   acc = coeffs(10)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(6)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(5)*q1 + coeffs(4)
   reg4 = acc*q1
   acc = coeffs(3)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   ctenseval6_2 = acc
end  function ctenseval6_2
!****f* src/interface/tens_rec/solve6_3
! NAME
!
!  Subroutine solve6_3
!
! USAGE
!
!  call solve6_3(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q6_3.
!  The matrix mat6_3 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_6 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve6_3(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(3), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_6), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(20) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,20
      Q(indices(1)) = q6_3(i,1)
      Q(indices(2)) = q6_3(i,2)
      Q(indices(3)) = q6_3(i,3)
      xnum(i) = numeval(Q, mu2) - tenseval6(Q, coeffs, 2)
   end do
   coeffs%c3(idx,:) = matmul(mat6_3,xnum)
end subroutine solve6_3
!****f* src/interface/tens_rec/tenseval6_3
! NAME
!
! Function tenseval6_3
!
! USAGE
!
!  result = tenseval6_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(20) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval6_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(20), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval6_3
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(18)*q0 + coeffs(15)*q1 + coeffs(12) + coeffs(13)*q2
   reg2 = acc*q0
   acc = coeffs(9)*q1 + coeffs(6) + coeffs(7)*q2
   reg3 = acc*q1
   acc = coeffs(3) + coeffs(4)*q2
   reg4 = acc*q2
   acc = coeffs(2)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q2
   acc = coeffs(20)*q0 + coeffs(19)*q1 + coeffs(17)
   reg3 = acc*q0
   acc = coeffs(16)*q1 + coeffs(14)
   reg4 = acc*q1
   acc = coeffs(11)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(10)*q1 + coeffs(8)
   reg4 = acc*q1
   acc = coeffs(5)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   tenseval6_3 = acc
end  function tenseval6_3
!****f* src/interface/tens_rec/ctenseval6_3
! NAME
!
! Function ctenseval6_3
!
! USAGE
!
!  result = ctenseval6_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(20) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval6_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(20), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval6_3
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(18)*q0 + coeffs(15)*q1 + coeffs(12) + coeffs(13)*q2
   reg2 = acc*q0
   acc = coeffs(9)*q1 + coeffs(6) + coeffs(7)*q2
   reg3 = acc*q1
   acc = coeffs(3) + coeffs(4)*q2
   reg4 = acc*q2
   acc = coeffs(2)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q2
   acc = coeffs(20)*q0 + coeffs(19)*q1 + coeffs(17)
   reg3 = acc*q0
   acc = coeffs(16)*q1 + coeffs(14)
   reg4 = acc*q1
   acc = coeffs(11)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(10)*q1 + coeffs(8)
   reg4 = acc*q1
   acc = coeffs(5)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   ctenseval6_3 = acc
end  function ctenseval6_3
!****f* src/interface/tens_rec/solve6_4
! NAME
!
!  Subroutine solve6_4
!
! USAGE
!
!  call solve6_4(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q6_4.
!  The matrix mat6_4 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_6 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve6_4(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(4), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_6), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(15) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   do i=1,15
      Q(indices(1)) = q6_4(i,1)
      Q(indices(2)) = q6_4(i,2)
      Q(indices(3)) = q6_4(i,3)
      Q(indices(4)) = q6_4(i,4)
      xnum(i) = numeval(Q, mu2) - tenseval6(Q, coeffs, 3)
   end do
   coeffs%c4(idx,:) = matmul(mat6_4,xnum)
end subroutine solve6_4
!****f* src/interface/tens_rec/tenseval6_4
! NAME
!
! Function tenseval6_4
!
! USAGE
!
!  result = tenseval6_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(15) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval6_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(15), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval6_4
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   real(ki) :: q3
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(12)*q3 + coeffs(11) + coeffs(15)*q0 + coeffs(14)*q1
   acc = acc + coeffs(13)*q2
   reg1 = acc*q0
   acc = coeffs(8)*q3 + coeffs(7) + coeffs(10)*q1 + coeffs(9)*q2
   reg2 = acc*q1
   acc = coeffs(5)*q3 + coeffs(4) + coeffs(6)*q2
   reg3 = acc*q2
   acc = coeffs(3)*q3 + coeffs(2)
   reg4 = acc*q3
   acc = coeffs(1)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2*q3
   tenseval6_4 = acc
end  function tenseval6_4
!****f* src/interface/tens_rec/ctenseval6_4
! NAME
!
! Function ctenseval6_4
!
! USAGE
!
!  result = ctenseval6_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(15) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval6_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(15), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval6_4
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: q3
   complex(ki) :: reg4
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(12)*q3 + coeffs(11) + coeffs(15)*q0 + coeffs(14)*q1
   acc = acc + coeffs(13)*q2
   reg1 = acc*q0
   acc = coeffs(8)*q3 + coeffs(7) + coeffs(10)*q1 + coeffs(9)*q2
   reg2 = acc*q1
   acc = coeffs(5)*q3 + coeffs(4) + coeffs(6)*q2
   reg3 = acc*q2
   acc = coeffs(3)*q3 + coeffs(2)
   reg4 = acc*q3
   acc = coeffs(1)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2*q3
   ctenseval6_4 = acc
end  function ctenseval6_4
!****f* src/interface/tens_rec/solve6
! NAME
!
! Subroutine solve6
!
! USAGE
!
!  call solve6(numeval, mu2, coeffs)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 6
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_6 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve6(numeval, mu2, coeffs)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_6), intent(inout) :: coeffs
   coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
   call solve6_1(numeval, (/0/), mu2, coeffs, 1)
   call solve6_1(numeval, (/1/), mu2, coeffs, 2)
   call solve6_1(numeval, (/2/), mu2, coeffs, 3)
   call solve6_1(numeval, (/3/), mu2, coeffs, 4)
   call solve6_2(numeval, (/0,1/), mu2, coeffs, 1)
   call solve6_2(numeval, (/0,2/), mu2, coeffs, 2)
   call solve6_2(numeval, (/0,3/), mu2, coeffs, 3)
   call solve6_2(numeval, (/1,2/), mu2, coeffs, 4)
   call solve6_2(numeval, (/1,3/), mu2, coeffs, 5)
   call solve6_2(numeval, (/2,3/), mu2, coeffs, 6)
   call solve6_3(numeval, (/0,1,2/), mu2, coeffs, 1)
   call solve6_3(numeval, (/0,1,3/), mu2, coeffs, 2)
   call solve6_3(numeval, (/0,2,3/), mu2, coeffs, 3)
   call solve6_3(numeval, (/1,2,3/), mu2, coeffs, 4)
   call solve6_4(numeval, (/0,1,2,3/), mu2, coeffs, 1)
end subroutine solve6
!****f* src/interface/tens_rec/tenseval6
! NAME
!
! Function tenseval6
!
! USAGE
!
!  result = tenseval6(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_6
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval6(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_6), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval6
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 4
   end if
   tenseval6 = coeffs%c0
   if (1 .le. maxk) then
      tenseval6 = tenseval6 + tenseval6_1(Q, (/0/), coeffs%c1(1,:))
      tenseval6 = tenseval6 + tenseval6_1(Q, (/1/), coeffs%c1(2,:))
      tenseval6 = tenseval6 + tenseval6_1(Q, (/2/), coeffs%c1(3,:))
      tenseval6 = tenseval6 + tenseval6_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval6 = tenseval6 + tenseval6_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval6 = tenseval6 + tenseval6_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval6 = tenseval6 + tenseval6_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval6 = tenseval6 + tenseval6_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval6 = tenseval6 + tenseval6_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval6 = tenseval6 + tenseval6_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
   if (3 .le. maxk) then
      tenseval6 = tenseval6 + tenseval6_3(Q, (/0,1,2/), coeffs%c3(1,:))
      tenseval6 = tenseval6 + tenseval6_3(Q, (/0,1,3/), coeffs%c3(2,:))
      tenseval6 = tenseval6 + tenseval6_3(Q, (/0,2,3/), coeffs%c3(3,:))
      tenseval6 = tenseval6 + tenseval6_3(Q, (/1,2,3/), coeffs%c3(4,:))
   end if
   if (4 .le. maxk) then
      tenseval6 = tenseval6 + tenseval6_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
   end if
end  function tenseval6
!****f* src/interface/tens_rec/ctenseval6
! NAME
!
! Function ctenseval6
!
! USAGE
!
!  result = ctenseval6(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_6
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval6(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_6), intent(in) :: coeffs
   complex(ki) :: ctenseval6
   ctenseval6 = coeffs%c0
   ctenseval6 = ctenseval6 + ctenseval6_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval6 = ctenseval6 + ctenseval6_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval6 = ctenseval6 + ctenseval6_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval6 = ctenseval6 + ctenseval6_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval6 = ctenseval6 + ctenseval6_2(Q, (/2,3/), coeffs%c2(6,:))
   ctenseval6 = ctenseval6 + ctenseval6_3(Q, (/0,1,2/), coeffs%c3(1,:))
   ctenseval6 = ctenseval6 + ctenseval6_3(Q, (/0,1,3/), coeffs%c3(2,:))
   ctenseval6 = ctenseval6 + ctenseval6_3(Q, (/0,2,3/), coeffs%c3(3,:))
   ctenseval6 = ctenseval6 + ctenseval6_3(Q, (/1,2,3/), coeffs%c3(4,:))
   ctenseval6 = ctenseval6 + ctenseval6_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
end  function ctenseval6
!****f* src/interface/tens_rec/print_coeffs_6
! NAME
!
! Subroutine print_coeffs_6
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 6
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_6
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_6(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_6), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,3), ')*q(0)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,4), ')*q(0)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,5), ')*q(0)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,6), ')*q(0)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,3), ')*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,4), ')*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,5), ')*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,6), ')*q(1)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,3), ')*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,4), ')*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,5), ')*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,6), ')*q(2)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,3), ')*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,4), ')*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,5), ')*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,6), ')*q(3)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,2), ')*q(0)*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,3), ')*q(0)*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,4), ')*q(0)*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,5), ')*q(0)*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,6), ')*q(0)^2*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,7), ')*q(0)^2*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,8), ')*q(0)^2*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,9), ')*q(0)^2*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,10), ')*q(0)^3*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,11), ')*q(0)^3*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,12), ')*q(0)^3*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,13), ')*q(0)^4*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,14), ')*q(0)^4*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,15), ')*q(0)^5*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,2), ')*q(0)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,3), ')*q(0)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,4), ')*q(0)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,5), ')*q(0)*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,6), ')*q(0)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,7), ')*q(0)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,8), ')*q(0)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,9), ')*q(0)^2*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,10), ')*q(0)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,11), ')*q(0)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,12), ')*q(0)^3*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,13), ')*q(0)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,14), ')*q(0)^4*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,15), ')*q(0)^5*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,2), ')*q(0)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,3), ')*q(0)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,4), ')*q(0)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,5), ')*q(0)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,6), ')*q(0)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,7), ')*q(0)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,8), ')*q(0)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,9), ')*q(0)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,10), ')*q(0)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,11), ')*q(0)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,12), ')*q(0)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,13), ')*q(0)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,14), ')*q(0)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,15), ')*q(0)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,2), ')*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,3), ')*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,4), ')*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,5), ')*q(1)*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,6), ')*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,7), ')*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,8), ')*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,9), ')*q(1)^2*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,10), ')*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,11), ')*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,12), ')*q(1)^3*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,13), ')*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,14), ')*q(1)^4*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,15), ')*q(1)^5*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,2), ')*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,3), ')*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,4), ')*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,5), ')*q(1)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,6), ')*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,7), ')*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,8), ')*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,9), ')*q(1)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,10), ')*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,11), ')*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,12), ')*q(1)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,13), ')*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,14), ')*q(1)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,15), ')*q(1)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,2), ')*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,3), ')*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,4), ')*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,5), ')*q(2)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,6), ')*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,7), ')*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,8), ')*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,9), ')*q(2)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,10), ')*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,11), ')*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,12), ')*q(2)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,13), ')*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,14), ')*q(2)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,15), ')*q(2)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(1,1), ')*q(0)*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,2), ')*q(0)*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,3), ')*q(0)*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,4), ')*q(0)*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,5), ')*q(0)*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,6), ')*q(0)*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,7), ')*q(0)*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,8), ')*q(0)*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,9), ')*q(0)*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,10), ')*q(0)*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,11), ')*q(0)^2*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,12), ')*q(0)^2*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,13), ')*q(0)^2*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,14), ')*q(0)^2*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(1,15), ')*q(0)^2*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,16), ')*q(0)^2*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,17), ')*q(0)^3*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,18), ')*q(0)^3*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,19), ')*q(0)^3*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,20), ')*q(0)^4*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(2,1), ')*q(0)*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,2), ')*q(0)*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,3), ')*q(0)*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,4), ')*q(0)*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,5), ')*q(0)*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,6), ')*q(0)*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,7), ')*q(0)*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,8), ')*q(0)*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,9), ')*q(0)*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,10), ')*q(0)*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,11), ')*q(0)^2*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,12), ')*q(0)^2*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,13), ')*q(0)^2*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,14), ')*q(0)^2*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(2,15), ')*q(0)^2*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,16), ')*q(0)^2*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,17), ')*q(0)^3*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,18), ')*q(0)^3*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,19), ')*q(0)^3*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,20), ')*q(0)^4*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(3,1), ')*q(0)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,2), ')*q(0)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,3), ')*q(0)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,4), ')*q(0)*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,5), ')*q(0)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,6), ')*q(0)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,7), ')*q(0)*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,8), ')*q(0)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,9), ')*q(0)*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,10), ')*q(0)*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,11), ')*q(0)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,12), ')*q(0)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,13), ')*q(0)^2*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,14), ')*q(0)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(3,15), ')*q(0)^2*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,16), ')*q(0)^2*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,17), ')*q(0)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,18), ')*q(0)^3*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,19), ')*q(0)^3*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,20), ')*q(0)^4*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(4,1), ')*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,2), ')*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,3), ')*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,4), ')*q(1)*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,5), ')*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,6), ')*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,7), ')*q(1)*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,8), ')*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,9), ')*q(1)*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,10), ')*q(1)*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,11), ')*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,12), ')*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,13), ')*q(1)^2*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,14), ')*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(4,15), ')*q(1)^2*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,16), ')*q(1)^2*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,17), ')*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,18), ')*q(1)^3*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,19), ')*q(1)^3*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,20), ')*q(1)^4*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A21)') ' + (',  coeffs%c4(1,1), ')*q(0)*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,2), ')*q(0)*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,3), ')*q(0)*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,4), ')*q(0)*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,5), ')*q(0)*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,6), ')*q(0)*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,7), ')*q(0)*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,8), ')*q(0)*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,9), ')*q(0)*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,10), ')*q(0)*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,11), ')*q(0)^2*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,12), ')*q(0)^2*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,13), ')*q(0)^2*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,14), ')*q(0)^2*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,15), ')*q(0)^3*q(1)*q(2)*q(3)'
end subroutine print_coeffs_6
!****f* src/interface/tens_rec/reconstruct6
! NAME
!
! Subroutine reconstruct6
!
! USAGE
!
!  call reconstruct6(numeval, cm0, cm1, cm2, cm3)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 6,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_6, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type type(coeff_type_4), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type type(coeff_type_4), representing the
!               tensor in front of mu2^2 [optional]
!  * cm3     -- coefficients of type type(coeff_type_4), representing the
!               tensor in front of mu2^3 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1, cm2 and cm3 (if present). If cm1, cm2 and cm3 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2. If cm3 is omitted it is assumed that the numerator
!  is at most quadratic in mu2.
! EXAMPLE
!
!
!*****
subroutine     reconstruct6(numeval, cm0, cm1, cm2, cm3)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_6), intent(out) :: cm0
   type(coeff_type_4), intent(out), optional :: cm1
   type(coeff_type_4), intent(out), optional :: cm2
   type(coeff_type_4), intent(out), optional :: cm3
   type(coeff_type_4) :: ca, cb
   type(coeff_type_4) :: cc
   call solve6(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         if (present(cm3)) then
            call solve4(numeval, +1.0_ki, ca, cm0)
            call solve4(numeval, -1.0_ki, cb, cm0)
            call solve4(numeval, +2.0_ki, cc, cm0)
            cm3%c0= -0.5_ki*ca%c0+(cc%c0-cb%c0)/6._ki
            cm2%c0= 0.5_ki*(ca%c0+cb%c0)
            cm1%c0= ca%c0 - cb%c0/3._ki - cc%c0/6._ki
            cm3%c1= -0.5_ki*ca%c1+(cc%c1-cb%c1)/6._ki
            cm2%c1= 0.5_ki*(ca%c1+cb%c1)
            cm1%c1= ca%c1 - cb%c1/3._ki - cc%c1/6._ki
            cm3%c2= -0.5_ki*ca%c2+(cc%c2-cb%c2)/6._ki
            cm2%c2= 0.5_ki*(ca%c2+cb%c2)
            cm1%c2= ca%c2 - cb%c2/3._ki - cc%c2/6._ki
            cm3%c3= -0.5_ki*ca%c3+(cc%c3-cb%c3)/6._ki
            cm2%c3= 0.5_ki*(ca%c3+cb%c3)
            cm1%c3= ca%c3 - cb%c3/3._ki - cc%c3/6._ki
            cm3%c4= -0.5_ki*ca%c4+(cc%c4-cb%c4)/6._ki
            cm2%c4= 0.5_ki*(ca%c4+cb%c4)
            cm1%c4= ca%c4 - cb%c4/3._ki - cc%c4/6._ki
         else
            call solve4(numeval, +1.0_ki, ca, cm0)
            call solve4(numeval, -1.0_ki, cb, cm0)
            cm1%c0= 0.5_ki * (ca%c0 - cb%c0)
            cm2%c0= 0.5_ki * (ca%c0 + cb%c0)
            cm1%c1 = 0.5_ki * (ca%c1 - cb%c1)
            cm2%c1 = 0.5_ki * (ca%c1 + cb%c1)
            cm1%c2 = 0.5_ki * (ca%c2 - cb%c2)
            cm2%c2 = 0.5_ki * (ca%c2 + cb%c2)
            cm1%c3 = 0.5_ki * (ca%c3 - cb%c3)
            cm2%c3 = 0.5_ki * (ca%c3 + cb%c3)
            cm1%c4 = 0.5_ki * (ca%c4 - cb%c4)
            cm2%c4 = 0.5_ki * (ca%c4 + cb%c4)
         end if
      else
         call solve4(numeval, +1.0_ki, cm1, cm0)
      end if
   end if
end subroutine reconstruct6
!****f* src/interface/tens_rec/solve7_1
! NAME
!
!  Subroutine solve7_1
!
! USAGE
!
!  call solve7_1(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q7_1.
!  The matrix mat7_1 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_7 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve7_1(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(1), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_7), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(7) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,7
      Q(indices(1)) = q7_1(i,1)
      xnum(i) = numeval(Q, mu2) - tenseval7(Q, coeffs, 0)
   end do
   coeffs%c1(idx,:) = matmul(mat7_1,xnum)
end subroutine solve7_1
!****f* src/interface/tens_rec/tenseval7_1
! NAME
!
! Function tenseval7_1
!
! USAGE
!
!  result = tenseval7_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(7) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval7_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(7), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval7_1
   real(ki) :: q0
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(6) + coeffs(7)*q0
   reg5 = acc*q0
   acc = coeffs(5)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(4)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   tenseval7_1 = acc
end  function tenseval7_1
!****f* src/interface/tens_rec/ctenseval7_1
! NAME
!
! Function ctenseval7_1
!
! USAGE
!
!  result = ctenseval7_1(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  1 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(1): the set of non-zero indices.
!  * coeffs  -- an array of dimension(7) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 1 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval7_1(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(1), intent(in) :: indices
   complex(ki), dimension(7), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval7_1
   complex(ki) :: q0
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   acc = coeffs(6) + coeffs(7)*q0
   reg5 = acc*q0
   acc = coeffs(5)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(4)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(3)
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(2)
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(1)
   acc = acc + reg1
   acc = acc*q0
   ctenseval7_1 = acc
end  function ctenseval7_1
!****f* src/interface/tens_rec/solve7_2
! NAME
!
!  Subroutine solve7_2
!
! USAGE
!
!  call solve7_2(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q7_2.
!  The matrix mat7_2 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_7 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve7_2(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(2), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_7), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(21) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,21
      Q(indices(1)) = q7_2(i,1)
      Q(indices(2)) = q7_2(i,2)
      xnum(i) = numeval(Q, mu2) - tenseval7(Q, coeffs, 1)
   end do
   coeffs%c2(idx,:) = matmul(mat7_2,xnum)
end subroutine solve7_2
!****f* src/interface/tens_rec/tenseval7_2
! NAME
!
! Function tenseval7_2
!
! USAGE
!
!  result = tenseval7_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(21) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval7_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(21), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval7_2
   real(ki) :: q0
   real(ki) :: q1
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(18)*q1 + coeffs(20)*q0 + coeffs(17)
   reg4 = acc*q0
   acc = coeffs(15)*q1 + coeffs(14)
   reg5 = acc*q1
   acc = coeffs(13)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(21)*q0 + coeffs(19)
   reg5 = acc*q0
   acc = coeffs(16)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(12)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(11)*q1 + coeffs(10)
   reg5 = acc*q1
   acc = coeffs(9)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(8)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(7)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(6)*q1 + coeffs(5)
   reg5 = acc*q1
   acc = coeffs(4)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(3)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   tenseval7_2 = acc
end  function tenseval7_2
!****f* src/interface/tens_rec/ctenseval7_2
! NAME
!
! Function ctenseval7_2
!
! USAGE
!
!  result = ctenseval7_2(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  2 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(2): the set of non-zero indices.
!  * coeffs  -- an array of dimension(21) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 2 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval7_2(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(2), intent(in) :: indices
   complex(ki), dimension(21), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval7_2
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   acc = coeffs(18)*q1 + coeffs(20)*q0 + coeffs(17)
   reg4 = acc*q0
   acc = coeffs(15)*q1 + coeffs(14)
   reg5 = acc*q1
   acc = coeffs(13)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(21)*q0 + coeffs(19)
   reg5 = acc*q0
   acc = coeffs(16)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(12)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q0
   acc = coeffs(11)*q1 + coeffs(10)
   reg5 = acc*q1
   acc = coeffs(9)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(8)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(7)
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q0
   acc = coeffs(6)*q1 + coeffs(5)
   reg5 = acc*q1
   acc = coeffs(4)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(3)
   acc = acc + reg4
   reg3 = acc*q1
   acc = coeffs(2)
   acc = acc + reg3
   reg2 = acc*q1
   acc = coeffs(1)
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1
   ctenseval7_2 = acc
end  function ctenseval7_2
!****f* src/interface/tens_rec/solve7_3
! NAME
!
!  Subroutine solve7_3
!
! USAGE
!
!  call solve7_3(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q7_3.
!  The matrix mat7_3 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_7 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve7_3(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(3), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_7), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(35) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   Q(:)=0.0_ki
   do i=1,35
      Q(indices(1)) = q7_3(i,1)
      Q(indices(2)) = q7_3(i,2)
      Q(indices(3)) = q7_3(i,3)
      xnum(i) = numeval(Q, mu2) - tenseval7(Q, coeffs, 2)
   end do
   coeffs%c3(idx,:) = matmul(mat7_3,xnum)
end subroutine solve7_3
!****f* src/interface/tens_rec/tenseval7_3
! NAME
!
! Function tenseval7_3
!
! USAGE
!
!  result = tenseval7_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(35) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval7_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(35), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval7_3
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(30)*q0 + coeffs(24)*q1 + coeffs(21) + coeffs(22)*q2
   reg3 = acc*q0
   acc = coeffs(14)*q1 + coeffs(11) + coeffs(12)*q2
   reg4 = acc*q1
   acc = coeffs(8) + coeffs(9)*q2
   reg5 = acc*q2
   acc = coeffs(7)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(34)*q0 + coeffs(31)*q1 + coeffs(29)
   reg4 = acc*q0
   acc = coeffs(25)*q1 + coeffs(23)
   reg5 = acc*q1
   acc = coeffs(20)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(15)*q1 + coeffs(13)
   reg5 = acc*q1
   acc = coeffs(10)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(6)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(28)*q0 + coeffs(18) + coeffs(19)*q2
   reg4 = acc*q0
   acc = coeffs(4) + coeffs(5)*q2
   reg5 = acc*q2
   acc = coeffs(3)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q2
   acc = coeffs(33)*q0 + coeffs(27)
   reg5 = acc*q0
   acc = coeffs(17)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(2)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(35)*q0 + coeffs(32)
   reg5 = acc*q0
   acc = coeffs(26)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(16)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   tenseval7_3 = acc
end  function tenseval7_3
!****f* src/interface/tens_rec/ctenseval7_3
! NAME
!
! Function ctenseval7_3
!
! USAGE
!
!  result = ctenseval7_3(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  3 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(3): the set of non-zero indices.
!  * coeffs  -- an array of dimension(35) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 3 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval7_3(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(3), intent(in) :: indices
   complex(ki), dimension(35), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval7_3
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   acc = coeffs(30)*q0 + coeffs(24)*q1 + coeffs(21) + coeffs(22)*q2
   reg3 = acc*q0
   acc = coeffs(14)*q1 + coeffs(11) + coeffs(12)*q2
   reg4 = acc*q1
   acc = coeffs(8) + coeffs(9)*q2
   reg5 = acc*q2
   acc = coeffs(7)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(34)*q0 + coeffs(31)*q1 + coeffs(29)
   reg4 = acc*q0
   acc = coeffs(25)*q1 + coeffs(23)
   reg5 = acc*q1
   acc = coeffs(20)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(15)*q1 + coeffs(13)
   reg5 = acc*q1
   acc = coeffs(10)
   acc = acc + reg5
   reg4 = acc*q1
   acc = coeffs(6)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(28)*q0 + coeffs(18) + coeffs(19)*q2
   reg4 = acc*q0
   acc = coeffs(4) + coeffs(5)*q2
   reg5 = acc*q2
   acc = coeffs(3)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q2
   acc = coeffs(33)*q0 + coeffs(27)
   reg5 = acc*q0
   acc = coeffs(17)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(2)
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(35)*q0 + coeffs(32)
   reg5 = acc*q0
   acc = coeffs(26)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(16)
   acc = acc + reg4
   reg3 = acc*q0
   acc = coeffs(1)
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2
   ctenseval7_3 = acc
end  function ctenseval7_3
!****f* src/interface/tens_rec/solve7_4
! NAME
!
!  Subroutine solve7_4
!
! USAGE
!
!  call solve7_4(numeval, indices, mu2, coeffs, idx)
!
! DESCRIPTION
!
!  This subroutine solves a system generated by substituting the
!  non-zero components of q in the numerator function numeval(q,mu2)
!  for the values given in the array q7_4.
!  The matrix mat7_4 is the inverse matrix of the left hand side
!  of the original system.
!
! INPUTS
!
!  * numeval -- a function representing the numerator function
!               N(q, mu2) where q(0:3) is a real vector,
!               mu2 is a real number and the result of numeval is complex
!  * indices -- array of integers indicating the non-zero entries of q
!  * mu2     -- fixed value for mu2 passed to numeval
!  * coeffs  -- coefficients of type coeff_type_7 to be solved for
!  * idx     -- label indicating which entries in coeffs the given set
!               of indices corresponds to
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  No return value
!
! EXAMPLE
!
!
!*****
subroutine     solve7_4(numeval, indices, mu2, coeffs, idx)
   ! generated by: write_subroutine_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   integer, dimension(4), intent(in) :: indices
   real(ki), intent(in) :: mu2
   type(coeff_type_7), intent(inout) :: coeffs
   integer, intent(in) :: idx
   complex(ki), dimension(35) :: xnum
   real(ki), dimension(0:3) :: Q
   integer :: i
   do i=1,35
      Q(indices(1)) = q7_4(i,1)
      Q(indices(2)) = q7_4(i,2)
      Q(indices(3)) = q7_4(i,3)
      Q(indices(4)) = q7_4(i,4)
      xnum(i) = numeval(Q, mu2) - tenseval7(Q, coeffs, 3)
   end do
   coeffs%c4(idx,:) = matmul(mat7_4,xnum)
end subroutine solve7_4
!****f* src/interface/tens_rec/tenseval7_4
! NAME
!
! Function tenseval7_4
!
! USAGE
!
!  result = tenseval7_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(35) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function tenseval7_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(35), intent(in) :: coeffs
   real(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: tenseval7_4
   real(ki) :: q0
   real(ki) :: q1
   real(ki) :: q2
   real(ki) :: q3
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(28)*q3 + coeffs(27) + coeffs(34)*q0 + coeffs(30)*q1
   acc = acc + coeffs(29)*q2
   reg2 = acc*q0
   acc = coeffs(18)*q3 + coeffs(17) + coeffs(20)*q1 + coeffs(19)*q2
   reg3 = acc*q1
   acc = coeffs(15)*q3 + coeffs(14) + coeffs(16)*q2
   reg4 = acc*q2
   acc = coeffs(13)*q3 + coeffs(12)
   reg5 = acc*q3
   acc = coeffs(11)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(9)*q3 + coeffs(8) + coeffs(26)*q0 + coeffs(10)*q2
   reg3 = acc*q2
   acc = coeffs(25)*q3 + coeffs(24) + coeffs(33)*q0
   reg4 = acc*q0
   acc = coeffs(7)*q3 + coeffs(6)
   reg5 = acc*q3
   acc = coeffs(5)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(23)*q3 + coeffs(22) + coeffs(32)*q0
   reg4 = acc*q0
   acc = coeffs(4)*q3 + coeffs(3)
   reg5 = acc*q3
   acc = coeffs(2)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q3
   acc = coeffs(31) + coeffs(35)*q0
   reg5 = acc*q0
   acc = coeffs(21)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(1)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2*q3
   tenseval7_4 = acc
end  function tenseval7_4
!****f* src/interface/tens_rec/ctenseval7_4
! NAME
!
! Function ctenseval7_4
!
! USAGE
!
!  result = ctenseval7_4(Q, indices, coeffs)
!
! DESCRIPTION
!
!  Recomputes the part of N(Q) from the coefficients where Q has exactly
!  4 non-zero entries identified by the array indices.
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * indices -- array of dimension(4): the set of non-zero indices.
!  * coeffs  -- an array of dimension(35) holding the coefficients.
!               as defined in the corresponding derived type.
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) coming from the terms where
!  exactly the 4 entries of q specified in indices are non-zero.
!
! EXAMPLE
!
!
!*****
pure function ctenseval7_4(Q, indices, coeffs)
   ! generated by: write_function_recon
   implicit none
   integer, dimension(4), intent(in) :: indices
   complex(ki), dimension(35), intent(in) :: coeffs
   complex(ki), dimension(0:3), intent(in) :: Q
   complex(ki) :: ctenseval7_4
   complex(ki) :: q0
   complex(ki) :: q1
   complex(ki) :: q2
   complex(ki) :: q3
   complex(ki) :: reg4
   complex(ki) :: reg5
   complex(ki) :: reg2
   complex(ki) :: reg3
   complex(ki) :: reg1
   complex(ki) :: acc
   q0 = Q(indices(1))
   q1 = Q(indices(2))
   q2 = Q(indices(3))
   q3 = Q(indices(4))
   acc = coeffs(28)*q3 + coeffs(27) + coeffs(34)*q0 + coeffs(30)*q1
   acc = acc + coeffs(29)*q2
   reg2 = acc*q0
   acc = coeffs(18)*q3 + coeffs(17) + coeffs(20)*q1 + coeffs(19)*q2
   reg3 = acc*q1
   acc = coeffs(15)*q3 + coeffs(14) + coeffs(16)*q2
   reg4 = acc*q2
   acc = coeffs(13)*q3 + coeffs(12)
   reg5 = acc*q3
   acc = coeffs(11)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   reg1 = acc*q1
   acc = coeffs(9)*q3 + coeffs(8) + coeffs(26)*q0 + coeffs(10)*q2
   reg3 = acc*q2
   acc = coeffs(25)*q3 + coeffs(24) + coeffs(33)*q0
   reg4 = acc*q0
   acc = coeffs(7)*q3 + coeffs(6)
   reg5 = acc*q3
   acc = coeffs(5)
   acc = acc + reg5
   acc = acc + reg4
   acc = acc + reg3
   reg2 = acc*q2
   acc = coeffs(23)*q3 + coeffs(22) + coeffs(32)*q0
   reg4 = acc*q0
   acc = coeffs(4)*q3 + coeffs(3)
   reg5 = acc*q3
   acc = coeffs(2)
   acc = acc + reg5
   acc = acc + reg4
   reg3 = acc*q3
   acc = coeffs(31) + coeffs(35)*q0
   reg5 = acc*q0
   acc = coeffs(21)
   acc = acc + reg5
   reg4 = acc*q0
   acc = coeffs(1)
   acc = acc + reg4
   acc = acc + reg3
   acc = acc + reg2
   acc = acc + reg1
   acc = acc*q0*q1*q2*q3
   ctenseval7_4 = acc
end  function ctenseval7_4
!****f* src/interface/tens_rec/solve7
! NAME
!
! Subroutine solve7
!
! USAGE
!
!  call solve7(numeval, mu2, coeffs)
!
! DESCRIPTION
!
!  Determines the tensor coefficients of a numerator for a fixed value
!  of mu^2 with maximum rank 7
!
! INPUTS
!
!  * numeval -- function representing the numerator of the problem
!  * mu2     -- fixed value of mu^2 for which the numerator is evaluated
!  * coeffs  -- a record of type coeff_type_7 used to store the result
!
! SIDE EFFECTS
!
!  No side effect
!
! EXAMPLE
!
!
!*****
subroutine     solve7(numeval, mu2, coeffs)
   ! generated by: write_subroutine_glob_solve
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   real(ki), intent(in) :: mu2
   type(coeff_type_7), intent(inout) :: coeffs
   coeffs%c0 = numeval((/0.0_ki,0.0_ki,0.0_ki,0.0_ki/), mu2)
   call solve7_1(numeval, (/0/), mu2, coeffs, 1)
   call solve7_1(numeval, (/1/), mu2, coeffs, 2)
   call solve7_1(numeval, (/2/), mu2, coeffs, 3)
   call solve7_1(numeval, (/3/), mu2, coeffs, 4)
   call solve7_2(numeval, (/0,1/), mu2, coeffs, 1)
   call solve7_2(numeval, (/0,2/), mu2, coeffs, 2)
   call solve7_2(numeval, (/0,3/), mu2, coeffs, 3)
   call solve7_2(numeval, (/1,2/), mu2, coeffs, 4)
   call solve7_2(numeval, (/1,3/), mu2, coeffs, 5)
   call solve7_2(numeval, (/2,3/), mu2, coeffs, 6)
   call solve7_3(numeval, (/0,1,2/), mu2, coeffs, 1)
   call solve7_3(numeval, (/0,1,3/), mu2, coeffs, 2)
   call solve7_3(numeval, (/0,2,3/), mu2, coeffs, 3)
   call solve7_3(numeval, (/1,2,3/), mu2, coeffs, 4)
   call solve7_4(numeval, (/0,1,2,3/), mu2, coeffs, 1)
end subroutine solve7
!****f* src/interface/tens_rec/tenseval7
! NAME
!
! Function tenseval7
!
! USAGE
!
!  result = tenseval7(Q, coeffs, max_k)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a real vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_7
!  * max_k   -- optional integer argument limiting the the reconstruction
!               to a subset of terms with no more than max_k components of q
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function tenseval7(Q, coeffs, max_k)
   ! generated by: write_function_glob_recon
   implicit none
   real(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_7), intent(in) :: coeffs
   integer, intent(in), optional :: max_k
   complex(ki) :: tenseval7
   integer :: maxk
   if (present(max_k)) then
      maxk = max_k
   else
      maxk = 4
   end if
   tenseval7 = coeffs%c0
   if (1 .le. maxk) then
      tenseval7 = tenseval7 + tenseval7_1(Q, (/0/), coeffs%c1(1,:))
      tenseval7 = tenseval7 + tenseval7_1(Q, (/1/), coeffs%c1(2,:))
      tenseval7 = tenseval7 + tenseval7_1(Q, (/2/), coeffs%c1(3,:))
      tenseval7 = tenseval7 + tenseval7_1(Q, (/3/), coeffs%c1(4,:))
   end if
   if (2 .le. maxk) then
      tenseval7 = tenseval7 + tenseval7_2(Q, (/0,1/), coeffs%c2(1,:))
      tenseval7 = tenseval7 + tenseval7_2(Q, (/0,2/), coeffs%c2(2,:))
      tenseval7 = tenseval7 + tenseval7_2(Q, (/0,3/), coeffs%c2(3,:))
      tenseval7 = tenseval7 + tenseval7_2(Q, (/1,2/), coeffs%c2(4,:))
      tenseval7 = tenseval7 + tenseval7_2(Q, (/1,3/), coeffs%c2(5,:))
      tenseval7 = tenseval7 + tenseval7_2(Q, (/2,3/), coeffs%c2(6,:))
   end if
   if (3 .le. maxk) then
      tenseval7 = tenseval7 + tenseval7_3(Q, (/0,1,2/), coeffs%c3(1,:))
      tenseval7 = tenseval7 + tenseval7_3(Q, (/0,1,3/), coeffs%c3(2,:))
      tenseval7 = tenseval7 + tenseval7_3(Q, (/0,2,3/), coeffs%c3(3,:))
      tenseval7 = tenseval7 + tenseval7_3(Q, (/1,2,3/), coeffs%c3(4,:))
   end if
   if (4 .le. maxk) then
      tenseval7 = tenseval7 + tenseval7_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
   end if
end  function tenseval7
!****f* src/interface/tens_rec/ctenseval7
! NAME
!
! Function ctenseval7
!
! USAGE
!
!  result = ctenseval7(Q, coeffs)
!
! DESCRIPTION
!
!  Recomputes N(Q) from a set of tensor coefficients
!
! INPUTS
!
!  * Q       -- a complex vector of dimension(0:3)
!  * coeffs  -- a record of type coeff_type_7
!
! SIDE EFFECTS
!
!  No side effect
!
! RETURN VALUE
!
!  The value of the part of N(q) as reconstructed from the coefficients
!
! EXAMPLE
!
!
!*****
pure function ctenseval7(Q, coeffs)
   ! generated by: write_function_glob_recon_complex
   implicit none
   complex(ki), dimension(0:3), intent(in) :: Q
   type(coeff_type_7), intent(in) :: coeffs
   complex(ki) :: ctenseval7
   ctenseval7 = coeffs%c0
   ctenseval7 = ctenseval7 + ctenseval7_1(Q, (/0/), coeffs%c1(1,:))
   ctenseval7 = ctenseval7 + ctenseval7_1(Q, (/1/), coeffs%c1(2,:))
   ctenseval7 = ctenseval7 + ctenseval7_1(Q, (/2/), coeffs%c1(3,:))
   ctenseval7 = ctenseval7 + ctenseval7_1(Q, (/3/), coeffs%c1(4,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/0,1/), coeffs%c2(1,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/0,2/), coeffs%c2(2,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/0,3/), coeffs%c2(3,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/1,2/), coeffs%c2(4,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/1,3/), coeffs%c2(5,:))
   ctenseval7 = ctenseval7 + ctenseval7_2(Q, (/2,3/), coeffs%c2(6,:))
   ctenseval7 = ctenseval7 + ctenseval7_3(Q, (/0,1,2/), coeffs%c3(1,:))
   ctenseval7 = ctenseval7 + ctenseval7_3(Q, (/0,1,3/), coeffs%c3(2,:))
   ctenseval7 = ctenseval7 + ctenseval7_3(Q, (/0,2,3/), coeffs%c3(3,:))
   ctenseval7 = ctenseval7 + ctenseval7_3(Q, (/1,2,3/), coeffs%c3(4,:))
   ctenseval7 = ctenseval7 + ctenseval7_4(Q, (/0,1,2,3/), coeffs%c4(1,:))
end  function ctenseval7
!****f* src/interface/tens_rec/print_coeffs_7
! NAME
!
! Subroutine print_coeffs_7
!
! Visible through public interface print_coeffs
!
! USAGE
!
!  call print_coeffs(coeffs,unit=6)
!
! DESCRIPTION
!
!  Prints the coefficients of a numerator of maximum rank 7
!  in human readable form.
!
! INPUTS
!
!  * coeffs  -- a record of type coeff_type_7
!  * unit    -- number of an open file, defaults to stdout (unit=6)
!
! SIDE EFFECTS
!
!  Prints to the given file
!
! EXAMPLE
!
!
!*****
subroutine print_coeffs_7(coeffs, unit)
   ! generated by: write_print_coeffs
   implicit none
   type(coeff_type_7), intent(in) :: coeffs
   integer, intent(in), optional :: unit
   integer :: ch
   if (present(unit)) then
      ch = unit
   else
      ch = 6
   end if
   write(ch,'(A4,G24.16,1x,G24.16,A1)') '   (', coeffs%c0, ')'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(1,1), ')*q(0)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,2), ')*q(0)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,3), ')*q(0)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,4), ')*q(0)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,5), ')*q(0)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,6), ')*q(0)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(1,7), ')*q(0)^7'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(2,1), ')*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,2), ')*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,3), ')*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,4), ')*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,5), ')*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,6), ')*q(1)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(2,7), ')*q(1)^7'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(3,1), ')*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,2), ')*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,3), ')*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,4), ')*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,5), ')*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,6), ')*q(2)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(3,7), ')*q(2)^7'
   write(ch,'(A4,G24.16,1x,G24.16,A6)') ' + (',  coeffs%c1(4,1), ')*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,2), ')*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,3), ')*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,4), ')*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,5), ')*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,6), ')*q(3)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A8)') ' + (',  coeffs%c1(4,7), ')*q(3)^7'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(1,1), ')*q(0)*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,2), ')*q(0)*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,3), ')*q(0)*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,4), ')*q(0)*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,5), ')*q(0)*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,6), ')*q(0)*q(1)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,7), ')*q(0)^2*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,8), ')*q(0)^2*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,9), ')*q(0)^2*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,10), ')*q(0)^2*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,11), ')*q(0)^2*q(1)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,12), ')*q(0)^3*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,13), ')*q(0)^3*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,14), ')*q(0)^3*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,15), ')*q(0)^3*q(1)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,16), ')*q(0)^4*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,17), ')*q(0)^4*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,18), ')*q(0)^4*q(1)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,19), ')*q(0)^5*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(1,20), ')*q(0)^5*q(1)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(1,21), ')*q(0)^6*q(1)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(2,1), ')*q(0)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,2), ')*q(0)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,3), ')*q(0)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,4), ')*q(0)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,5), ')*q(0)*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,6), ')*q(0)*q(2)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,7), ')*q(0)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,8), ')*q(0)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,9), ')*q(0)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,10), ')*q(0)^2*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,11), ')*q(0)^2*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,12), ')*q(0)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,13), ')*q(0)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,14), ')*q(0)^3*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,15), ')*q(0)^3*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,16), ')*q(0)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,17), ')*q(0)^4*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,18), ')*q(0)^4*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,19), ')*q(0)^5*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(2,20), ')*q(0)^5*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(2,21), ')*q(0)^6*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(3,1), ')*q(0)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,2), ')*q(0)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,3), ')*q(0)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,4), ')*q(0)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,5), ')*q(0)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,6), ')*q(0)*q(3)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,7), ')*q(0)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,8), ')*q(0)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,9), ')*q(0)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,10), ')*q(0)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,11), ')*q(0)^2*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,12), ')*q(0)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,13), ')*q(0)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,14), ')*q(0)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,15), ')*q(0)^3*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,16), ')*q(0)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,17), ')*q(0)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,18), ')*q(0)^4*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,19), ')*q(0)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(3,20), ')*q(0)^5*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(3,21), ')*q(0)^6*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(4,1), ')*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,2), ')*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,3), ')*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,4), ')*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,5), ')*q(1)*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,6), ')*q(1)*q(2)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,7), ')*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,8), ')*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,9), ')*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,10), ')*q(1)^2*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,11), ')*q(1)^2*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,12), ')*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,13), ')*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,14), ')*q(1)^3*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,15), ')*q(1)^3*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,16), ')*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,17), ')*q(1)^4*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,18), ')*q(1)^4*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,19), ')*q(1)^5*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(4,20), ')*q(1)^5*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(4,21), ')*q(1)^6*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(5,1), ')*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,2), ')*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,3), ')*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,4), ')*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,5), ')*q(1)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,6), ')*q(1)*q(3)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,7), ')*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,8), ')*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,9), ')*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,10), ')*q(1)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,11), ')*q(1)^2*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,12), ')*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,13), ')*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,14), ')*q(1)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,15), ')*q(1)^3*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,16), ')*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,17), ')*q(1)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,18), ')*q(1)^4*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,19), ')*q(1)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(5,20), ')*q(1)^5*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(5,21), ')*q(1)^6*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A11)') ' + (',  coeffs%c2(6,1), ')*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,2), ')*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,3), ')*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,4), ')*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,5), ')*q(2)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,6), ')*q(2)*q(3)^6'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,7), ')*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,8), ')*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,9), ')*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,10), ')*q(2)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,11), ')*q(2)^2*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,12), ')*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,13), ')*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,14), ')*q(2)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,15), ')*q(2)^3*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,16), ')*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,17), ')*q(2)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,18), ')*q(2)^4*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,19), ')*q(2)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A15)') ' + (',  coeffs%c2(6,20), ')*q(2)^5*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A13)') ' + (',  coeffs%c2(6,21), ')*q(2)^6*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(1,1), ')*q(0)*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,2), ')*q(0)*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,3), ')*q(0)*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,4), ')*q(0)*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,5), ')*q(0)*q(1)*q(2)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,6), ')*q(0)*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,7), ')*q(0)*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,8), ')*q(0)*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,9), ')*q(0)*q(1)^2*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,10), ')*q(0)*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,11), ')*q(0)*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,12), ')*q(0)*q(1)^3*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,13), ')*q(0)*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,14), ')*q(0)*q(1)^4*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,15), ')*q(0)*q(1)^5*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,16), ')*q(0)^2*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,17), ')*q(0)^2*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,18), ')*q(0)^2*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,19), ')*q(0)^2*q(1)*q(2)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,20), ')*q(0)^2*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(1,21), ')*q(0)^2*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(1,22), ')*q(0)^2*q(1)^2*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,23), ')*q(0)^2*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(1,24), ')*q(0)^2*q(1)^3*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,25), ')*q(0)^2*q(1)^4*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,26), ')*q(0)^3*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,27), ')*q(0)^3*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,28), ')*q(0)^3*q(1)*q(2)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,29), ')*q(0)^3*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(1,30), ')*q(0)^3*q(1)^2*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,31), ')*q(0)^3*q(1)^3*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,32), ')*q(0)^4*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,33), ')*q(0)^4*q(1)*q(2)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(1,34), ')*q(0)^4*q(1)^2*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(1,35), ')*q(0)^5*q(1)*q(2)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(2,1), ')*q(0)*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,2), ')*q(0)*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,3), ')*q(0)*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,4), ')*q(0)*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,5), ')*q(0)*q(1)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,6), ')*q(0)*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,7), ')*q(0)*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,8), ')*q(0)*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,9), ')*q(0)*q(1)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,10), ')*q(0)*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,11), ')*q(0)*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,12), ')*q(0)*q(1)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,13), ')*q(0)*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,14), ')*q(0)*q(1)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,15), ')*q(0)*q(1)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,16), ')*q(0)^2*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,17), ')*q(0)^2*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,18), ')*q(0)^2*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,19), ')*q(0)^2*q(1)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,20), ')*q(0)^2*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(2,21), ')*q(0)^2*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(2,22), ')*q(0)^2*q(1)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,23), ')*q(0)^2*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(2,24), ')*q(0)^2*q(1)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,25), ')*q(0)^2*q(1)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,26), ')*q(0)^3*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,27), ')*q(0)^3*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,28), ')*q(0)^3*q(1)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,29), ')*q(0)^3*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(2,30), ')*q(0)^3*q(1)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,31), ')*q(0)^3*q(1)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,32), ')*q(0)^4*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,33), ')*q(0)^4*q(1)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(2,34), ')*q(0)^4*q(1)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(2,35), ')*q(0)^5*q(1)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(3,1), ')*q(0)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,2), ')*q(0)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,3), ')*q(0)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,4), ')*q(0)*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,5), ')*q(0)*q(2)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,6), ')*q(0)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,7), ')*q(0)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,8), ')*q(0)*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,9), ')*q(0)*q(2)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,10), ')*q(0)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,11), ')*q(0)*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,12), ')*q(0)*q(2)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,13), ')*q(0)*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,14), ')*q(0)*q(2)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,15), ')*q(0)*q(2)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,16), ')*q(0)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,17), ')*q(0)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,18), ')*q(0)^2*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,19), ')*q(0)^2*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,20), ')*q(0)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(3,21), ')*q(0)^2*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(3,22), ')*q(0)^2*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,23), ')*q(0)^2*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(3,24), ')*q(0)^2*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,25), ')*q(0)^2*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,26), ')*q(0)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,27), ')*q(0)^3*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,28), ')*q(0)^3*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,29), ')*q(0)^3*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(3,30), ')*q(0)^3*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,31), ')*q(0)^3*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,32), ')*q(0)^4*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,33), ')*q(0)^4*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(3,34), ')*q(0)^4*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(3,35), ')*q(0)^5*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A16)') ' + (',  coeffs%c3(4,1), ')*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,2), ')*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,3), ')*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,4), ')*q(1)*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,5), ')*q(1)*q(2)*q(3)^5'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,6), ')*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,7), ')*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,8), ')*q(1)*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,9), ')*q(1)*q(2)^2*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,10), ')*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,11), ')*q(1)*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,12), ')*q(1)*q(2)^3*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,13), ')*q(1)*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,14), ')*q(1)*q(2)^4*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,15), ')*q(1)*q(2)^5*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,16), ')*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,17), ')*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,18), ')*q(1)^2*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,19), ')*q(1)^2*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,20), ')*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(4,21), ')*q(1)^2*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(4,22), ')*q(1)^2*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,23), ')*q(1)^2*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(4,24), ')*q(1)^2*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,25), ')*q(1)^2*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,26), ')*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,27), ')*q(1)^3*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,28), ')*q(1)^3*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,29), ')*q(1)^3*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A22)') ' + (',  coeffs%c3(4,30), ')*q(1)^3*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,31), ')*q(1)^3*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,32), ')*q(1)^4*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,33), ')*q(1)^4*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A20)') ' + (',  coeffs%c3(4,34), ')*q(1)^4*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A18)') ' + (',  coeffs%c3(4,35), ')*q(1)^5*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A21)') ' + (',  coeffs%c4(1,1), ')*q(0)*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,2), ')*q(0)*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,3), ')*q(0)*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,4), ')*q(0)*q(1)*q(2)*q(3)^4'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,5), ')*q(0)*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,6), ')*q(0)*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,7), ')*q(0)*q(1)*q(2)^2*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,8), ')*q(0)*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,9), ')*q(0)*q(1)*q(2)^3*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,10), ')*q(0)*q(1)*q(2)^4*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,11), ')*q(0)*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,12), ')*q(0)*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,13), ')*q(0)*q(1)^2*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,14), ')*q(0)*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A27)') ' + (',  coeffs%c4(1,15), ')*q(0)*q(1)^2*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,16), ')*q(0)*q(1)^2*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,17), ')*q(0)*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,18), ')*q(0)*q(1)^3*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,19), ')*q(0)*q(1)^3*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,20), ')*q(0)*q(1)^4*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,21), ')*q(0)^2*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,22), ')*q(0)^2*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,23), ')*q(0)^2*q(1)*q(2)*q(3)^3'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,24), ')*q(0)^2*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A27)') ' + (',  coeffs%c4(1,25), ')*q(0)^2*q(1)*q(2)^2*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,26), ')*q(0)^2*q(1)*q(2)^3*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,27), ')*q(0)^2*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A27)') ' + (',  coeffs%c4(1,28), ')*q(0)^2*q(1)^2*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A27)') ' + (',  coeffs%c4(1,29), ')*q(0)^2*q(1)^2*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,30), ')*q(0)^2*q(1)^3*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,31), ')*q(0)^3*q(1)*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,32), ')*q(0)^3*q(1)*q(2)*q(3)^2'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,33), ')*q(0)^3*q(1)*q(2)^2*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A25)') ' + (',  coeffs%c4(1,34), ')*q(0)^3*q(1)^2*q(2)*q(3)'
   write(ch,'(A4,G24.16,1x,G24.16,A23)') ' + (',  coeffs%c4(1,35), ')*q(0)^4*q(1)*q(2)*q(3)'
end subroutine print_coeffs_7
!****f* src/interface/tens_rec/reconstruct7
! NAME
!
! Subroutine reconstruct7
!
! USAGE
!
!  call reconstruct7(numeval, cm0, cm1, cm2, cm3)
!
! DESCRIPTION
!
!  Reconstructs all coefficients of a tensor integral of maximum rank 7,
!  including the coefficients in front of mu2 and mu2^2.
!
! INPUTS
!
!  * numeval -- the numerator function
!  * cm0     -- coefficients of type coeff_type_7, representing the
!               numerator at mu2=0
!  * cm1     -- coefficients of type type(coeff_type_5), representing the
!               tensor in front of mu2 [optional]
!  * cm2     -- coefficients of type type(coeff_type_5), representing the
!               tensor in front of mu2^2 [optional]
!  * cm3     -- coefficients of type type(coeff_type_5), representing the
!               tensor in front of mu2^3 [optional]
!
! SIDE EFFECTS
!
!  Writes results to cm0, cm1, cm2 and cm3 (if present). If cm1, cm2 and cm3 are omitted
!  only N(q,0) is evaluated. If cm2 is omitted it is assumed that the numerator
!  is at most linear in mu2. If cm3 is omitted it is assumed that the numerator
!  is at most quadratic in mu2.
! EXAMPLE
!
!
!*****
subroutine     reconstruct7(numeval, cm0, cm1, cm2, cm3)
   ! generated by: write_subroutine_reconstruct
   implicit none
   interface
      function numeval(Q, mu2)
         use precision_golem, only: ki
         implicit none
         real(ki), dimension(0:3), intent(in) :: Q
         real(ki), intent(in) :: mu2
         complex(ki) :: numeval
      end function numeval
   end interface
   type(coeff_type_7), intent(out) :: cm0
   type(coeff_type_5), intent(out), optional :: cm1
   type(coeff_type_5), intent(out), optional :: cm2
   type(coeff_type_5), intent(out), optional :: cm3
   type(coeff_type_5) :: ca, cb
   type(coeff_type_5) :: cc
   call solve7(numeval, 0.0_ki, cm0)
   if (present(cm1)) then
      if (present(cm2)) then
         if (present(cm3)) then
            call solve5(numeval, +1.0_ki, ca, cm0)
            call solve5(numeval, -1.0_ki, cb, cm0)
            call solve5(numeval, +2.0_ki, cc, cm0)
            cm3%c0= -0.5_ki*ca%c0+(cc%c0-cb%c0)/6._ki
            cm2%c0= 0.5_ki*(ca%c0+cb%c0)
            cm1%c0= ca%c0 - cb%c0/3._ki - cc%c0/6._ki
            cm3%c1= -0.5_ki*ca%c1+(cc%c1-cb%c1)/6._ki
            cm2%c1= 0.5_ki*(ca%c1+cb%c1)
            cm1%c1= ca%c1 - cb%c1/3._ki - cc%c1/6._ki
            cm3%c2= -0.5_ki*ca%c2+(cc%c2-cb%c2)/6._ki
            cm2%c2= 0.5_ki*(ca%c2+cb%c2)
            cm1%c2= ca%c2 - cb%c2/3._ki - cc%c2/6._ki
            cm3%c3= -0.5_ki*ca%c3+(cc%c3-cb%c3)/6._ki
            cm2%c3= 0.5_ki*(ca%c3+cb%c3)
            cm1%c3= ca%c3 - cb%c3/3._ki - cc%c3/6._ki
            cm3%c4= -0.5_ki*ca%c4+(cc%c4-cb%c4)/6._ki
            cm2%c4= 0.5_ki*(ca%c4+cb%c4)
            cm1%c4= ca%c4 - cb%c4/3._ki - cc%c4/6._ki
         else
            call solve5(numeval, +1.0_ki, ca, cm0)
            call solve5(numeval, -1.0_ki, cb, cm0)
            cm1%c0= 0.5_ki * (ca%c0 - cb%c0)
            cm2%c0= 0.5_ki * (ca%c0 + cb%c0)
            cm1%c1 = 0.5_ki * (ca%c1 - cb%c1)
            cm2%c1 = 0.5_ki * (ca%c1 + cb%c1)
            cm1%c2 = 0.5_ki * (ca%c2 - cb%c2)
            cm2%c2 = 0.5_ki * (ca%c2 + cb%c2)
            cm1%c3 = 0.5_ki * (ca%c3 - cb%c3)
            cm2%c3 = 0.5_ki * (ca%c3 + cb%c3)
            cm1%c4 = 0.5_ki * (ca%c4 - cb%c4)
            cm2%c4 = 0.5_ki * (ca%c4 + cb%c4)
         end if
      else
         call solve5(numeval, +1.0_ki, cm1, cm0)
      end if
   end if
end subroutine reconstruct7
end module tens_rec
